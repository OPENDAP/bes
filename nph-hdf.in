#!@PERL@ -T

# Replace the above two lines witn #!/path/to/your/perl to avoid the overhead
# of first running the shell and then starting perl. 

# Do dispatch for DODS servers. Use the `MIME type extension' of the URL to
# select the correct DODS server program. This dispatch cgi assumes that the
# DODS data server consists of three programs: *_das, *_dds and *_dods, where
# `*' is the root name of the dispatch program. Each of these programs takes
# one or two arguments; a file name and possibly a query string. 
#
# A Url is handled thus: 
# http://machine/cgi-bin/nph-nc/file.nc.dods?val
#                            ^^ ^^^^^^^ ^^^^ ^^^
#                            |  |       |    \
#                            |  |       \     - Constraint expression (arg 2)
#                            |  |        - selects filter (e.g., nc_*dods*)    
#                            | 	\			    		     
#      	       	       	     \ 	 - File to open (arg 1)			 
#      	       	       	      - Root name of the filter (e.g., *nc*_dods)
#
# NB: This script assumes that all data is rooted in the http document
# directory subtree. If you want to access files outside that subtree, use a
# symbolic link and make sure that your server is set to follow symbolic
# links. To configure your server to follow symbolic links, add
# FollowSymLinks to the Options in the access.conf file. 
#
# $Id$
#
# $Log: nph-hdf.in,v $
# Revision 1.9  2003/01/31 02:08:36  jimg
# Merged with release-3-2-7.
#
# Revision 1.7  2000/03/09 01:44:33  jimg
# merge with 3.1.3
#
# Revision 1.6.6.1  2000/02/12 05:07:00  jimg
# Changed Perl start up line to @PERL@ -T
#
# Revision 1.6  1999/05/24 17:36:12  jimg
# Security fixes; see nph-nc.in and DODS_Dispatch.pm
#
# Revision 1.5  1999/05/18 22:40:39  jimg
# Perl is now started using /bin/sh.
#
# Revision 1.4  1999/05/18 21:17:50  jimg
# Added simple test for perl. This won't do much for binaries...
#
# Revision 1.3  1999/05/05 02:03:12  jimg
# Added Version stuff.
#
# Revision 1.2  1998/09/26 04:09:34  jimg
# Changed the cache file `directory' separator from `.' to `#'.
#
# Revision 1.1  1998/09/24 23:05:51  jimg
# Created so that the cache can be set from configure
#
# Revision 1.12  1998/09/17 17:53:06  jimg
# Removed the old DODS_ROOT variable.
#
# Revision 1.11  1998/08/28 17:18:11  jimg
# Now works with the new cache scheme
#
# Revision 1.10  1998/01/09 23:32:25  jimg
# Added use of Cache manager.
#
# Revision 1.9  1997/06/12 21:05:42  jimg
# Switched to the new dispatch script.
# Removed the DODS_ROOT environment variable.
#
# Revision 1.8  1997/06/06 03:49:06  jimg
# Rewrote to use the new Perl DODS_Dispatch class.
#

$ENV{'PATH'} = '/bin:/usr/bin:/sbin:/usr/sbin';

use lib (".");			# Look for modules in the cwd.
use Env;
use DODS_Dispatch;
use DODS_Cache;

# This server can store cache files in a separate directory.  Set this to
# "" for the default behavior (store cache files in the same directory
# as the HDF file)
$cache_dir = "@HDF_CACHE@";

# 1048576 is one megabyte, thus this cache is 50MB in size.
purge_cache($cache_dir, 50 * 1048576, ".*\\.hdf.*");

# The DODS_Dispatch object reads information from the environment variables
# and builds up a command based on the format of a DODS URL. 
$dispatch = new DODS_Dispatch("hdf/@VERSION@", "support\@unidata.ucar.edu");

$file_name = $dispatch->filename();

# Is it a compressed file? .Z or .gz
$file_type = $file_name;
$file_type =~ s@.*\.(.*)@$1@;

if (($file_type eq "Z") || ($file_type eq "gz")) {
    $file_base = $file_name;
    # it would be good to remove the part of $file_base that is common with
    # $cache_dir. 9/25/98 jhrg
    $file_base =~ s@^/@@;  # delete leading /
    $file_base =~ s@/@#@g; # turn remaining / into #
    $file_base =~ s@.$file_type@@; # delete trailing filetype

    $UCfile_name = $cache_dir . "/" . $file_base; # new file path??

    # uncompressed file already in the cache dir...
    if ((! -e $UCfile_name) && (-e $file_name)) { 
	$uncomp = "gzip -c -d " . $file_name . " > " .  $UCfile_name;
	system($uncomp); # uncompress and put output to cache
    }
    
    $dispatch->filename($UCfile_name);
} 
# end if compressed file

$dispatch->cache_dir($cache_dir);

@command = $dispatch->command();

if ($command[0] ne "") {		# if no error...
    exec(@command);
} else {
    $dispatch->print_error_msg();
}
