#!/bin/bash
set -e
#set -x;

###############################################################################
#
# Default data root for BES
#
data_root=$(pwd)

###############################################################################
#
# Default BES Configuration.
#
BES_CONF_DOC=$(
    cat <<EOF
# produce DMR documents for use with build_dmrpp. The DAP, XML Command
# and HDF5 handler modules are the 'installed' ones (not the modules
# found in the build tree). jhrg 5/11/18

BES.ServerAdministrator=admin.email.address@your.domain.name

BES.User=user_name
BES.Group=group_name

BES.LogName=./bes.log
BES.LogVerbose=no

BES.modules=dap,cmd,h5,dmrpp

# Despite the comment at the top, use the development modules for now. jhrg 5/11/18

# BES.module.dap=@modulesdir@/libdap_module.so
# BES.module.cmd=@modulesdir@/libdap_xml_module.so
# BES.module.h5=@modulesdir@/libhdf5_module.so

BES.module.dap=@abs_top_builddir@/dap/.libs/libdap_module.so
BES.module.cmd=@abs_top_builddir@/xmlcommand/.libs/libdap_xml_module.so
BES.module.h5=@abs_top_builddir@/modules/hdf5_handler/.libs/libhdf5_module.so
BES.module.dmrpp=@abs_top_builddir@//modules/dmrpp_module/.libs/libdmrpp_module.so

# The value "@hdf5_root_directory@" is replaced at run time.
BES.Catalog.catalog.RootDirectory=@hdf5_root_directory@
BES.Data.RootDirectory=/dev/null

BES.Catalog.catalog.TypeMatch=h5:.*\.(h5|he5|nc4)(\.bz2|\.gz|\.Z)?$;
BES.Catalog.catalog.TypeMatch+=dmrpp:.*\.(dmrpp)$;

BES.Catalog.catalog.Include=;
BES.Catalog.catalog.Exclude=^\..*;

BES.FollowSymLinks=Yes
BES.Catalog.catalog.FollowSymLinks=Yes

BES.Info.Buffered=no
BES.Info.Type=xml

BES.UncompressCache.dir=/tmp/hyrax_ux
BES.UncompressCache.prefix=ux_
BES.UncompressCache.size=500
BES.Uncompress.Retry=2000
BES.Uncompress.NumTries=10

BES.Container.Persistence=strict

BES.Memory.GlobalArea.EmergencyPoolSize=1
BES.Memory.GlobalArea.MaximumHeapSize=20
BES.Memory.GlobalArea.Verbose=no
BES.Memory.GlobalArea.ControlHeap=no

BES.ProcessManagerMethod=multiple

BES.DefaultResponseMethod=POST

# Control the Metadata Response Store. Here, DAP metadata responses
# are stored/cached so that they can be returned by the server w/o
# having to touch the data files/objects. Setting the 'path' to null
# disables uses of the MDS. Setting 'size' to zero makes the MDS
# hold objects forever; setting a positive non-zero size makes the
# MDS behave like a cache, purging responses when the size is exceeded.

# FIXME This will need to be modified for the DMR++ responses when
# when enable Arch #2 since regenerating the DMR++ will be more
# expensive than regenerating other responses from files

DAP.GlobalMetadataStore.path = @abs_top_builddir@/modules/dmrpp_module/data/mds
DAP.GlobalMetadataStore.prefix = mds
DAP.GlobalMetadataStore.size = 0

# The MDS writes a ledger of additions and removals. By default the
# ledger is kept in 'mds_ledger.txt' in the directory used to start
# the BES.

DAP.GlobalMetadataStore.ledger = @abs_top_builddir@/modules/dmrpp_module/data/mds_ledger.txt

#-----------------------------------------------------------------------#
# HDF5 handler specific parameters: 
#-----------------------------------------------------------------------#
# EnableCF: Handle HDF data to follow the CF conventions
#   (true,yes|false,no, defaults to false)
# Since most centers  would like to handle HDF5 data that follows CF now,
# I set the EnableCF to be true, KY 2011-8-4
#
H5.EnableCF=true
H5.KeepVarLeadingUnderscore=false
H5.EnableCheckNameClashing=true
H5.EnableAddPathAttrs=true
H5.EnableDropLongString=true
H5.DisableStructMetaAttr=true
H5.EnableFillValueCheck=true
H5.CheckIgnoreObj=false
H5.MetaDataMemCacheEntries=300
H5.LargeDataMemCacheEntries=0
H5.SmallDataMemCacheEntries=0 
#H5.CachePurgeLevel=0.2

H5.EnableDiskMetaDataCache=false
H5.EnableDiskDDSCache=false
H5.DiskMetaDataCachePath=/tmp

H5.EnableEOSGeoCacheFile=false
H5.Cache.latlon.path=/tmp/latlon
H5.Cache.latlon.prefix=l
H5.Cache.latlon.size=20000

H5.EnableDiskDataCache=false
H5.DiskCacheDataPath=/tmp
H5.DiskCacheFilePrefix=c
H5.DiskCacheSize=10000
H5.DiskCacheComp=true
H5.DiskCacheFloatOnlyComp=true
H5.DiskCacheCompThreshold=2.0
H5.DiskCacheCompVarSize=10000

Gateway.Whitelist+=http://
Gateway.Whitelist+=https://

EOF
)
###############################################################################

###############################################################################
#
# Print the usage information.
#
show_usage() {
    cat <<EOF

 Usage: $0 [options] <hdf5 file>

 Write the DMR++ for hdf5_file to stdout

 By default the BES Data Root directory is set to the CWD. This
 utility will add an entry to the bes.log specified in the
 configuration file. The DMR++ is built using the DMR as returned
 by the HDF5 handler, using options as set in the bes
 configuration file found here.

 -h: Show help
 -v: Verbose: Print the DMR too
 -V: Very Verbose: print the DMR, the command and the configuration
     file used to build the DMR
 -r: Just print the DMR that will be used to build the DMR++
 -u: The binary object URL for use in the DMR++ file
 -d: Data root directory for the BES.
 -c: The path to the bes configuration file to use.
 -o: The name of the file  to create.
 -T: Run ALL hyrax tests on the resulting dmr++ file and compare the responses
     the ones generated by the source hdf5 file.
 -I: Run hyrax inventory tests on the resulting dmr++ file and compare the responses
     the ones generated by the source hdf5 file.
 -F: Run hyrax value probe tests on the resulting dmr++ file and compare the responses
     the ones generated by the source hdf5 file.

 Limitations: 
 * The pathanme to the hdf5 file must be relative from the
   directory where this command was run; absolute paths will not work.
 * The build_dmrpp command must be in the CWD.
 * The bes conf template has to build by hand. jhrg 5/11/18
EOF
}

OPTIND=1 # Reset in case getopts has been used previously in this shell

verbose=
very_verbose=
just_dmr=
dmrpp_url=
bes_conf_file=
run_inventory_tests=
run_value_tests=
output_file="${0}_result.dmrpp"

while getopts "h?vVru:d:o:c:TIF" opt; do
    case "$opt" in
    h | \?)
        show_usage
        exit 0
        ;;
    v)
        verbose="yes"
        echo "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
        echo "${0} - BEGIN (verbose)"
        ;;
    V)
        very_verbose="-v"
        verbose="yes"
        echo "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
        echo "${0} - BEGIN (very_verbose)"
        ;;
    c)
        bes_conf_file="$OPTARG"
        ;;
    r)
        just_dmr="yes"
        ;;
    u)
        dmrpp_url="$OPTARG"
        ;;
    d)
        data_root="$OPTARG"
        ;;
    o)
        output_file="$OPTARG"
        ;;
    T)
        run_inventory_tests="yes"
        run_value_tests="yes"
        ;;
    I)
        run_inventory_tests="yes"
        ;;
    F)
        run_value_tests="yes"
        ;;
    esac
done

shift $((OPTIND - 1))

[ "$1" = "--" ] && shift

if test -n "$very_verbose"; then
    set -x
fi

input_data_file="${1}"

if test -n "${verbose}"; then
    echo "    OUTPUT_FILE: ${output_file}"
    echo -n "       just_dmr: "
    if test -n "$just_dmr"; then
        echo "true"
    else
        echo "false"
    fi
    echo "      dmrpp_url: ${dmrpp_url}"
fi

if test -z "${dmrpp_url}"; then
    echo "ERROR! You must supply a dmrpp_url value using the -u option." >&2
    show_usage
    exit 666
fi

dap4ConstraintContainerElement=$(
    cat <<EOF
    <bes:container name="c">
      <bes:dap4constraint>${dap2_ce}</bes:dap4constraint>
    </bes:container>
EOF
)
dap2ConstraintContainerElement=$(
    cat <<EOF
    <bes:container name="c">
      <bes:constraint>${dap2_ce}</bes:constraint>
    </bes:container>
EOF
)
########################################################################################################################
# mkBesCmd()
# Creates a BES request document for the $dap_thing (dmr, ddx, etc)
# from the $source_data_path file and sticks the command in a temp file.
noConstraintContainerElement="<bes:container name=\"c\" />"

function mkDAP2BesCmd() {
    source_data_path="${1}"
    dap=${2}
    dap2_ce="${3}"
    if test -n "${dap2_ce}"; then
        #echo "Applying DAP2 CE: '${dap2_ce}'" >&2
container_element=$(cat <<EOF
    <bes:container name="c">
        <bes:constraint>${dap2_ce}</bes:constraint>
    </bes:container>
EOF
)
    else
        container_element="${noConstraintContainerElement}"
    fi
    #echo "Container Element: " >&2
    #echo "${container_element}" >&2

    d4BESCmd=$(
        cat <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<bes:request xmlns:bes="http://xml.opendap.org/ns/bes/1.0#" reqID="get_dmrpp.sh">
  <bes:setContext name="dap_explicit_containers">no</bes:setContext>
  <bes:setContext name="errors">xml</bes:setContext>
  <bes:setContext name="max_response_size">0</bes:setContext>

  <bes:setContainer name="c">${source_data_path}</bes:setContainer>

  <bes:define name="d" space="default">
${container_element}
  </bes:define>

  <bes:get type="${dap}" definition="d" />

</bes:request>

EOF
    )
    TEMP_FILE=$(mktemp -t dmr_XXXX)
    echo "${d4BESCmd}" >${TEMP_FILE}
    echo "${TEMP_FILE}"

    if test -n "$verbose"; then
        echo "      data_path: ${source_data_path}" >&2
        echo "        dap2_ce: '${dap2_ce}'" >&2
        echo "    ${dap}_request: ${TEMP_FILE} " >&2
        #echo " " >&2
    fi

    # ls -l ${TEMP_FILE}
    # cat ${TEMP_FILE}
}
########################################################################################################################

########################################################################################################################
# Prepare the bes.conf file - use external if provided otherwise use the here doc.
#
function make_bes_conf() {

    if test -n "${1}"; then
        if test -n "${verbose}"; then
            echo "Using BES Configuration: \"${1}\""
        fi
        BES_CONF_DOC=$(cat ${1})
    fi

    TMP_CONF=$(mktemp -t conf_XXXX)
    # Use the $data_root as the BES Data Root directory - this is a trick so that the
    # script can get a DMR using the HDF5 handler algorithm, as tweaked by the
    # handlers configuration parameters in the BES_CONF_DOC here document.
    echo "${BES_CONF_DOC}" | sed -e "s%[@]hdf5_root_directory[@]%${data_root}%" >${TMP_CONF}

    if test -n "$very_verbose"; then
        echo "TMP_CONF: ${TMP_CONF}" >&2
        ls -l ${TMP_CONF} >&2
        cat ${TMP_CONF} >&2
    fi

    echo "${TMP_CONF}"
    unset TMP_CONF
}
########################################################################################################################

########################################################################################################################
# getDap()
# Gets the passed $dap response (dmr, ddx, etc) for the file $data_path and places the reponse in a temp file.
#
function mkDapRequest() {
    data_path="${1}"
    dap=${2}
    DAP_CMD=$(mkDAP2BesCmd ${data_path} ${dap})
    #if test -n "${verbose}"; then echo "        DAP_CMD: ${DAP_CMD}" >&2; fi

    DAP_RESPONSE=$(mktemp -t dmr_XXXX)
    #if test -n "${verbose}"; then echo "   DAP_RESPONSE: ${DAP_RESPONSE}" >&2; fi

    besstandalone -c ${BES_CONF} -i ${DAP_CMD} >${DAP_RESPONSE}
    echo "${DAP_RESPONSE}"

    if test -n "$very_verbose"; then
        echo "${dap}_response: ${DAP_RESPONSE} data_path: ${data_path}" >&2
    fi

    if test -n "$very_verbose"; then
        echo "DAP_RESPONSE: " >&2
        cat ${DAP_RESPONSE} >&2
    fi
}
########################################################################################################################

########################################################################################################################
# mk_dmrpp()
# Uses build_dmrpp application to build the requested dmr++ file.
#
function mk_dmrpp() {
    datafile="${1}"
    full_data_path="${data_root}/${datafile}"
    if test -n "$verbose"; then
        echo "      data_root: ${data_root}"
        echo "       datafile: ${datafile}"
        echo " full_data_path: ${full_data_path}"
        echo "       bes.conf: ${BES_CONF}"
        echo "       dmr_file: ${SOURCE_DMR}"
        echo "      dmrpp_url: ${dmrpp_url}"
    fi
    if test -z "${just_dmr}"; then
        prms="${very_verbose}"
        prms="${prms} -c ${BES_CONF} "
        prms="${prms} -f ${full_data_path} "
        prms="${prms} -r ${SOURCE_DMR} "
        prms="${prms} -u ${dmrpp_url} "
        if test -n "$verbose"; then echo "   build_params: ${prms}" >&2; fi
        build_dmrpp ${prms} >"${output_file}"
    else
        echo "The just_dmr flag is set, skipping dmr++ construction."
    fi

    # TODO Use trap to ensure these are really removed
    # rm $DMR_CMD $SOURCE_DMR $TMP_CONF
}
########################################################################################################################

########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################

########################################################################################################################
# dap2_vars()
# Prints a list of DAP2 DDX variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap2_vars() {
    grep -e "<Byte" \
        -e "<Int" \
        -e "<UInt" \
        -e "<Float" \
        -e "<Float" \
        -e "<String" \
        -e "<URL" \
        -e "<Grid" \
        -e "<Sequence" \
        -e "<Structure" \
        -e "<Array" \
        "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap2_attributes()
# Prints a list of DAP2 DDX Attribute declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap2_attributes() {
    grep -e "<Attribute name=" -e "<Value>" "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap4_attributes()
# Prints a list of DAP4 DMR Attribute declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_attributes() {
    grep -e "<Attribute name=" -e "<Value>" "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_vars() {
    grep \
        -e "<Byte" \
        -e "<Int" \
        -e "<UInt" \
        -e "<Float" \
        -e "<String" \
        -e "<URI" \
        -e "<Enumeration" \
        -e "<Sequence" \
        -e "<Structure" \
        -e "<Array" \
        -e "<Group" \
        -e "<Dimension" \
        "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_array_counter() {
    dmr_file=${1}
    type=${2}

    #echo "    dmr_file: ${dmr_file}" >&2;
    #echo "   DAP4 type: ${type}" >&2;

    cat "${dmr_file}" | awk -v type=${type} 'BEGIN{
            inVar = 0;
            typeMatchString = "^ *<"type;
            closeMatchString = "^ *</"type;
            match_count=0;
       }
        {
        if( match($0,typeMatchString)==1){
            inVar=1;
            match_count++;
        }
        if( inVar>0){
            if( match($0,closeMatchString)==1){
                inVar=0;
            }
        }
    }END{print match_count;}' -

}
########################################################################################################################

function dap4_array_dim_counter() {
    dmr_file=${1}
    type=${2}
    match_num="${3}"
    awk_params="-v type=${type} -v match_num=${match_num}"

    cat "${dmr_file}" | awk ${awk_params} 'BEGIN{
            inVar = 0;
            typeMatchString = "^ *<"type;
            # print "typeMatchString: " typeMatchString;
            closeMatchString = "^ *</"type
            # print "closeMatchString: " closeMatchString;
            target_dim_count=0;
            match_count=0;
            target_var_name="not found";
        }
        {
        if( match($0,typeMatchString)==1){
            inVar=1;
            match_count++;
            if(match_count==match_num){
                # <Float32 name="ClrOLR_A">
                target_var_name=$2;
                sub("name=\"","",target_var_name);
                sub("\">","",target_var_name);
            }
        }
        if( inVar>0){
            if(match_count==match_num &&  match($0,"^ *<Dim")==1  ){
                target_dim_count++;
            }
            else if( match($0,closeMatchString)==1){
                inVar=0;
            }
        }
    }END{ print target_var_name, target_dim_count; }' -

}
########################################################################################################################

########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_array_test() {
    dmr_file=${1}
    type=${2}
    #echo "    dmr_file: ${dmr_file}" >&2;
    #echo "   DAP4 type: ${type}" >&2;

    var_count=$(dap4_array_counter ${dmr_file} ${type})
    if test -n "${verbose}"; then echo "Found ${var_count} variables of type ${type} in DMR: ${dmr_file}" >&2; fi
    if [ ${var_count} -lt 1 ]; then
        echo "ERROR! No variables found in DMR!" >&2
        return 1
    fi

    pick_var=$(echo "${var_count}*${RANDOM}/32767" | bc)
    if test -n "${verbose}"; then echo "Picked variable: ${pick_var}" >&2; fi

    name_and_dim=$(dap4_array_dim_counter ${dmr_file} ${type} ${pick_var})
    if test -n "${very_verbose}"; then echo "name_and_dim: ${name_and_dim}" >&2; fi

    var_name=$(echo "${name_and_dim}" | awk '{print $1;}' -)
    if test -n "${very_verbose}"; then echo "var_name: ${var_name}" >&2; fi

    var_dims=$(echo "${name_and_dim}" | awk '{print $2;}' -)
    if test -n "${very_verbose}"; then echo "var_dims: ${var_dims}" >&2; fi

    query_string="${var_name}"
    for ((i = 1; i <= ${var_dims}; i++)); do
        query_string=${query_string}"[0]"
    done
    if test -n "${verbose}"; then echo "   query_string: ${query_string}" >&2; fi

    bes_cmd_file=$(mkDAP2BesCmd "${input_data_file}" "dods" "${query_string}")
    #if test -n "${verbose}"; then echo "bes_cmd_file: ${bes_cmd_file}" >&2; fi
    dap2_source_response=$(mktemp -t d4_array_test_XXXX)
    besstandalone -c ${BES_CONF} -i ${bes_cmd_file} >${dap2_source_response}
    if test -n "${verbose}"; then echo "dap2_source_response: ${dap2_source_response}" >&2; fi
    if test -n "${verbose}"; then getdap -D -M ${dap2_source_response} >&2; fi

    if test -n "$very_verbose"; then
        echo "dap2_source_response: " >&2
        cat ${dap2_source_response} >&2
    fi

    bes_cmd_file=$(mkDAP2BesCmd "${output_file}" "dods" "${query_string}")
    #if test -n "$verbose"; then echo "bes_cmd_file: ${bes_cmd_file}" >&2; fi
    dap2_dmrpp_response=$(mktemp -t d4_array_test_XXXX)
    besstandalone -c ${BES_CONF} -i ${bes_cmd_file} >${dap2_dmrpp_response}
    if test -n "$verbose"; then echo "dap2_dmrpp_response: ${dap2_dmrpp_response}" >&2; fi
    if test -n "$verbose"; then getdap -D -M ${dap2_dmrpp_response} >&2; fi

    if test -n "$verbose"; then echo "Comparing binary responses..." >&2; fi
    cmp ${dap2_source_response} ${dap2_dmrpp_response} >&2
    if [ $? -eq 0 ]; then
        if test -n "$verbose"; then echo "Responses are the same. w00t" >&2; fi
        return 0
    else
        if test -n "$verbose"; then echo "ERROR! Responses differ." >&2; fi
        return 100
    fi

}

########################################################################################################################

########################################################################################################################
# compare_files()
# Compares two files by first applying the check_function to each file and then comparing the results of the
# check_function using diff.
#
function compare_files() {
    check_function=${1}
    first_file=${2}
    second_file=${3}
    success="${4}"
    failure="${5}"
    if test -n "$very_verbose"; then
        echo "compare_files() check_function: ${check_function}" >&2
        echo "compare_files()     first_file: ${first_file}" >&2
        echo "compare_files()    second_file: ${second_file}" >&2
    fi

    first_result=$(mktemp -t dmr_XXXX)
    if test -n "$very_verbose"; then
        echo "compare_files()   first_result: ${first_result}" >&2
    fi
    f_stuff=$(${check_function} ${first_file})
    echo "${f_stuff}" >${first_result}

    second_result=$(mktemp -t dmr_XXXX)
    if test -n "$very_verbose"; then
        echo "compare_files()  second_result: ${second_result}" >&2
    fi
    s_stuff=$(${check_function} ${second_file})
    echo "${s_stuff}" >${second_result}

    retval=0
    diff --ignore-space-change --brief ${first_result} ${second_result}
    if [ $? -eq 0 ]; then
        if test -n "${verbose}"; then
            echo "${success}" >&2
        fi
    else
        echo "${failure}" >&2
        retval=1
    fi
    return ${retval}
}
########################################################################################################################

########################################################################################################################
# dmrpp_inventory_test()
#
function dmrpp_inventory_test() {
    if test -n "${verbose}"; then
        echo "       BES_CONF: ${BES_CONF}" >&2
        echo "SOURCE_DATAFILE: ${input_data_file}" >&2
        echo "TARGET_DATAFILE: ${output_file}" >&2
    fi

    SOURCE_DDX=$(mkDapRequest "${input_data_file}" ddx)
    TARGET_DDX=$(mkDapRequest "${output_file}" ddx)

    # SOURCE_DMR=$(mkDapRequest "${input_data_file}" dmr) # This is done before the dmr++ file is built.
    TARGET_DMR=$(mkDapRequest "${output_file}" dmr)

    retval=0
    # echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap4_vars ${SOURCE_DMR} ${TARGET_DMR} " DAP4 variables: Matched." "ERROR! DAP4 variables mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap4_attributes ${SOURCE_DMR} ${TARGET_DMR} "DAP4 Attributes: Matched." "ERROR! DAP4 Attributes mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap2_vars ${SOURCE_DDX} ${TARGET_DDX} " DAP2 variables: Matched." "ERROR! DAP2 variables mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap2_attributes ${SOURCE_DDX} ${TARGET_DDX} "DAP2 Attributes: Matched." "ERROR! DAP2 Attributes mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    return ${retval}
}

function dmrpp_value_test() {
    if test -n "${very_verbose}"; then
        echo "dvt        BES_CONF: ${BES_CONF}" >&2
        echo "dvt SOURCE_DATAFILE: ${input_data_file}" >&2
        echo "dvt TARGET_DATAFILE: ${output_file}" >&2
        echo "dvt      SOURCE_DMR: ${SOURCE_DMR}" >&2
    fi
    dap4_array_test "${SOURCE_DMR}" "Float32"
    return $?
}
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################

BES_CONF=$(make_bes_conf "${bes_conf_file}")
SOURCE_DMR=$(mkDapRequest "${input_data_file}" dmr)
mk_dmrpp "${input_data_file}"
retval=$?;
#echo "retval: ${retval}";

if test -n "${run_inventory_tests}"; then
    dmrpp_inventory_test
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "retval: ${retval}";
fi

if test -n "${run_value_tests}"; then
    dmrpp_value_test
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "retval: ${retval}";
fi

#echo "retval: ${retval}";
exit $retval

# rm -f ${SOURCE_DMR} ${SOURCE_DDX} ${TARGET_DDX} ${TARGET_DMR} ${DDX_CMD} ${DMR_CMD} ${BES_CONF}

#./get_dmrpp -u "http://test.opendap.org/data/dmrpp/AIRS.2015.01.01.L3.RetStd_IR001.v6.0.11.0.G15013155825.nc.h5" -o airs.h5.dmrpp -T -v  airs.h5
#./get_dmrpp -u "http://test.opendap.org/data/dmrpp/SMAP_L3_SM_P_20150406_R14010_001.h5" -o smap.h5.dmrpp -T -v  smap.h5

