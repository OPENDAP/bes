#!/bin/bash
set -e
#set -x;

GET_DMRPP_VERSION="get_dmrpp-@get_dmrpp_version@";


###############################################################################
#
# Print the usage information.
#
function show_usage() {
    echo ""
    echo " [${GET_DMRPP_VERSION}]"
    cat <<EOF

Usage: $0 [options] <INPUT_DATA_FILE>

Write the DMR++ for INPUT_DATA_FILE (a hdf5/netcdf file) to stdout

* By default the BES Data Root directory is set to /tmp.
* This utility will add an entry to the bes.log specified in the
configuration.
* The DMR++ is built using the DMR as returned by the HDF5 handler
when invoked using options as set in the bes configuration the included
BES configuration as modified by the -s option or using the BES
configuration supplied with the -c option, see below.

-h: Show help
-z: Show version information (Verbose got here first.)
-v: Verbose: Print the DMR too
-V: Very Verbose: print the DMR, the command and the configuration
    file used to build the DMR, and do not remove temporary files.
-D: Just print the DMR that will be used to build the DMR++
-u: The binary object URL for use in the DMR++ file. If option '-u' is
    not used; then dap4:Dataset/@dmrpp:href attribute will contain the template string
    OPeNDAP_DMRpp_DATA_ACCESS_URL which can be replaced at runtime.
-b: The fully qualified path to the BES_DATA_ROOT directory. May not be "/" or "/etc".
    The default value is /tmp if a value is not provided
-c: The path to the bes configuration file to use.
-s: The path to an optional addendum configuration file which will be appended to the
    default BES configuration. Much like the site.conf file works for the full server
    deployment it will be loaded last and the settings there-in will have an override
    effect on the default configuration.
-o: The name of the dmr++ file to create. This is required when using -U so that the
    AWS CLI component has a file to transfer.
-e: The name of pre-existing dmr++ file to test.
-T: Run ALL hyrax tests on the resulting dmr++ file and compare the responses
    the ones generated by the source hdf5 file.
-I: Run hyrax inventory tests on the resulting dmr++ file and compare the responses
    the ones generated by the source hdf5 file.
-F: Run hyrax value probe tests on the resulting dmr++ file and compare the responses
    the ones generated by the source hdf5 file.
-M: Create and merge missing CF coordinate domain variables into the dmrpp. If there are
    missing variables, a sidecar file named <INPUT_DATA_FILE>.missing will be created
    in the same directory location as the INPUT_DATA_FILE.
    If option 'p' is not used; missing variable chunk href will contain OPeNDAP_DMRpp_MISSING_DATA_ACCESS_URL.
    If option 'p' is selected; missing variable chunk href will contain the argument provided to that option
-p: The value to use for each missing variable's dmrpp:chunk/@dmrpp:href attribute.  If option '-p' is
    not used; the missing variable dmrpp:chunk/@dmrpp:href attributes will contain the template string
    OPeNDAP_DMRpp_MISSING_DATA_ACCESS_URL which can be replaced at runtime.
-r: The path to the file that contains missing variable information for sets of input data files that share
    common missing variables. The file will be created if it doesn't exist and the result may be used in subsequent
    invocations of get_dmrpp (using -r) to identify the missing variable file.
-U: If present, and if the input data file is an AWS S3 URL (s3://...), and if the output data file has been set (using
    the -o option) the presence of this parameter will cause get_dmrpp to copy the finished dmr++ file to the same S3
    bucket location as the input data file. This must be used in conjunction with the -o switch as a local file is
    required before it can be transferred to S3.
-A: If present will cause the tool to use the "build" versions of the various component libraries as opposed to the
    nominal "install" version. This option is used by the autotest (aka make check/distcheck) targets for testing
    against builds that have not been installed.

Limitations:
* The name of the hdf5 file must be expressed relative to the BES_DATA_ROOT, or as an S3 URL (s3://...)

EOF
}

OPTIND=1 # Reset in case getopts has been used previously in this shell

VERBOSE=
VERY_VERBOSE=
JUST_DMR=
DMRPP_URL=
BES_CONF_FILE=
SITE_CONF_FILE=
RUN_INVENTORY_TESTS=
RUN_VALUE_TESTS=
MERGE_MISSING_VARS=
OUTPUT_FILE=
REDUCE_MISSING_FILES=
MASTER_SHA256=
BES_DATA_ROOT="/tmp"
EXISTING_DMRPP=
S3_UPLOAD=
USE_AUTOMAKE_LIBS=
CLEANUP_TEMP_FILES="true"
export TEMP_FILE_LIST=""

while getopts "h?vVDu:o:c:b:s:p:r:e:zTIFMUAX" opt; do
    case "$opt" in
    h | \?)
        show_usage >&2
        exit 0
        ;;
    z)
        echo "${GET_DMRPP_VERSION}" >&2
        exit 0
        ;;
    A)
        USE_AUTOMAKE_LIBS="true"
        ;;
    v)
        VERBOSE="yes"
        echo "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
        echo "${0} - BEGIN (VERBOSE)"
        ;;
    V)
        VERY_VERBOSE="-v"
        VERBOSE="yes"
        echo "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
        echo "${0} - BEGIN (VERY_VERBOSE)"
        ;;
    c)
        BES_CONF_FILE="$OPTARG"
        ;;
    s)
        SITE_CONF_FILE="$OPTARG"
        ;;
    b)
        BES_DATA_ROOT="$OPTARG"
        ;;
    M)
        MERGE_MISSING_VARS="yes"
        ;;
    p)
        MISSING_DATA_HREF="$OPTARG"
        ;;
    r)
        MASTER_SHA256="$OPTARG"
        REDUCE_MISSING_FILES="yes"
        ;;
    D)
        JUST_DMR="yes"
        ;;
    u)
        DMRPP_URL="$OPTARG"
        ;;
    o)
        OUTPUT_FILE="$OPTARG"
        ;;
    T)
        RUN_INVENTORY_TESTS="yes"
        RUN_VALUE_TESTS="yes"
        ;;
    I)
        RUN_INVENTORY_TESTS="yes"
        ;;
    F)
        RUN_VALUE_TESTS="yes"
        ;;
    e)
        EXISTING_DMRPP="$OPTARG"
        ;;
    U)
        S3_UPLOAD="yes"
        ;;
    X)
        CLEANUP_TEMP_FILES=
        ;;
    esac
done

shift $((OPTIND - 1))
[ "$1" = "--" ] && shift

if test -n "${VERY_VERBOSE}"; then
    set -x
fi

INPUT_DATA_FILE="${1}"

if test -n "${VERBOSE}"; then
    echo "    OUTPUT_FILE: ${OUTPUT_FILE}"
    echo -n "       JUST_DMR: "
    if test -n "${JUST_DMR}"; then
        echo "true"
    else
        echo "false"
    fi
    echo "      DMRPP_URL: ${DMRPP_URL}"
fi

if test -z "${DMRPP_URL}"; then
    DMRPP_URL="OPeNDAP_DMRpp_DATA_ACCESS_URL"
    echo "Using Template Data Access URL String: '${DMRPP_URL}'" >&2
fi

# If we are running tests then we need to have the output filename for the dmr++ content.
if [ -n "${RUN_INVENTORY_TESTS}" ] || [ -n "${RUN_VALUE_TESTS}" ]; then
    if [ -z "${OUTPUT_FILE}" ] && [ -z "${EXISTING_DMRPP}" ]; then
        echo "" >&2
        echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
        echo "" >&2
        echo "OUCH! In order to run the tests the dmr++ output must be written to a file using the -o option. " >&2
        echo "" >&2
        exit 1
    fi
fi

# If we are merging missing variables then we need to have the output filename for the dmr++ content.
if [ -n "${MERGE_MISSING_VARS}" ]; then
    if [ -z "${OUTPUT_FILE}" ]; then
        echo "" >&2
        echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
        echo "" >&2
        echo "OUCH! In order to merge missing variables the dmr++ output must be written to a file using the -o option. " >&2
        echo "" >&2
        exit 1
    fi
fi

###############################################################################
#
# cleanup_temp_files()
#
# Conditionally cleans up the list of temporary files created during the
# execution of this script.
# subshell: NEVER
#
function cleanup_temp_files(){
    if test -n "${CLEANUP_TEMP_FILES}"
    then
        echo "Cleaning up temporary files: ${TEMP_FILE_LIST}" >&2;
        rm -vf ${TEMP_FILE_LIST} >&2
        echo "Temporary files have been removed." >&2;
    fi
}

###############################################################################
#
# make_temp_file()
# subshell: NEVER
#
#
function make_temp_file(){
    local file_prefix="${1}"

    if test -n "${VERBOSE}"; then echo "make_temp_file() - file_prefix: ${file_prefix}" >&2; fi
    local tmp_file=$(mktemp "/tmp/${file_prefix}_XXXXXX")
    local retval=$?
    if test $? -ne 0
    then
        echo "make_temp_file() - ERROR: Failed to create temporary file. prefix: ${file_prefix}" >&2
        return $retval;
    fi
    if test -n "${VERBOSE}"; then echo "make_temp_file() - tmp_file: ${tmp_file}" >&2; fi

    export TEMP_FILE_LIST="${TEMP_FILE_LIST} ${tmp_file}"
    if test -n "${VERBOSE}"; then echo "make_temp_file() - TEMP_FILE_LIST: ${TEMP_FILE_LIST}" >&2; fi

    echo "${tmp_file}"
    export TEMP_FILE="${tmp_file}"
    return 0
}



###############################################################################
#
# mk_automake_conf()
# subshell: ALWAYS
#
# Returns the module libraries used by besstandalone when invoked by automake
# tasks like "make check" and "make distcheck". These are not the nominally
# installed libraries but rather the libs compiled by make check in the BES
# builddir.
#
function mk_automake_conf() {
    local config_doc=$(
    cat <<EOF
# -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
# These are the buildir libraries used for running make check/distcheck
BES.module.dap=@abs_top_builddir@/dap/.libs/libdap_module.so
BES.module.cmd=@abs_top_builddir@/xmlcommand/.libs/libdap_xml_module.so
BES.module.h5=@abs_top_builddir@/modules/hdf5_handler/.libs/libhdf5_module.so
BES.module.dmrpp=@abs_top_builddir@/modules/dmrpp_module/.libs/libdmrpp_module.so
BES.module.fonc=@abs_top_builddir@/modules/fileout_netcdf/.libs/libfonc_module.so
BES.module.nc=@abs_top_builddir@/modules/netcdf_handler/.libs/libnc_module.so
# -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
EOF
)
    if test -n "${VERBOSE}"; then echo "${config_doc}" >&2 ; fi
    echo "${config_doc}"
}


###############################################################################
#
# mk_default_bes_conf()
# subshell: NEVER
#
# Default BES Configuration.
#
function mk_default_bes_conf() {
    BES_CONF_DOC=$(
    cat <<EOF
# produce DMR documents for use with build_dmrpp. The DAP, XML Command
# and HDF5 handler modules are the 'installed' ones (not the modules
# found in the build tree). jhrg 5/11/18

BES.LogName=./bes.log

BES.modules=dap,cmd,h5,dmrpp,fonc,nc

BES.module.dap=@bes_modules_dir@/libdap_module.so
BES.module.cmd=@bes_modules_dir@/libdap_xml_module.so
BES.module.h5=@bes_modules_dir@/libhdf5_module.so
BES.module.dmrpp=@bes_modules_dir@/libdmrpp_module.so
BES.module.fonc=@bes_modules_dir@/libfonc_module.so
BES.module.nc=@bes_modules_dir@/libnc_module

# The value "@hdf5_root_directory@" is replaced at run time.
# BES.Catalog.catalog.RootDirectory=@hdf5_root_directory@
BES.Catalog.catalog.RootDirectory=${BES_DATA_ROOT}
BES.Data.RootDirectory=/dev/null

# The order is crucial here. The dmr++ files must be associated
# with the dmrpp_module while everything else is being
# gobbled up by the greedy regex for the hdf5_handler.
# If the dmrpp.TypeMatch doesn't come first then the
# hdf5_handler will claim the dmr++ files too.
BES.Catalog.catalog.TypeMatch=dmrpp:.*\.(dmrpp)$;
BES.Catalog.catalog.TypeMatch+=h5:.*(\.bz2|\.gz|\.Z)?$;

BES.Catalog.catalog.FollowSymLinks=Yes

BES.UncompressCache.dir=/tmp/hyrax_ux
BES.UncompressCache.prefix=ux_
BES.UncompressCache.size=500

AllowedHosts+=^https?:\/\/

#-----------------------------------------------------------------------#
# FONc handler specific parameters:
#-----------------------------------------------------------------------#
#Make sure this follows the netCDF-4 enhanced model
FONc.ClassicModel=false
#Don't generate global attributes since we only
#care about the variable value information.
FONc.NoGlobalAttrs=true

#-----------------------------------------------------------------------#
# HDF5 handler specific parameters:
#-----------------------------------------------------------------------#
# EnableCF: Groom the HDF5 data to follow the CF conventions
#   (true,yes|false,no, defaults to false)
#
# HDF5 handler keys that are not the compiled-in defaults. jhrg 5/24/22
H5.EnableCheckNameClashing=true
H5.EnableCF=false

EOF
)

    if test -n "${USE_AUTOMAKE_LIBS}"; then
        local automake_libs=$(mk_automake_conf)
        if test -n "${VERBOSE}"; then
            echo "mk_default_bes_conf() - Using automake_libs: " >&2
            echo "${automake_libs}" >&2
        fi
        export BES_CONF_DOC=$(echo "${BES_CONF_DOC}"; echo "${automake_libs}");
    fi

}
###############################################################################


dap4ConstraintContainerElement=$(
cat <<EOF
<bes:container name="c">
<bes:dap4constraint>${dap2_ce}</bes:dap4constraint>
</bes:container>
EOF
)
dap2ConstraintContainerElement=$(
cat <<EOF
<bes:container name="c">
<bes:constraint>${dap2_ce}</bes:constraint>
</bes:container>
EOF
)
########################################################################################################################
# mkBesCmd()
# subshell: ALWAYS
#
# Creates a BES request document for the $dap_thing (dmr, ddx, etc)
# from the $source_data_path file and sticks the command in a temp file.

function mkDAP2BesCmd() {
    local source_data_path="${1}"
    local dap=${2}
    local dap2_ce="${3}"
    local target_file="${4}"

    local noConstraintContainerElement="<bes:container name=\"c\" />"

    if test -n "${dap2_ce}"; then
        #echo "Applying DAP2 CE: '${dap2_ce}'" >&2
        container_element=$(
        cat <<EOF
<bes:container name="c">
<bes:constraint>${dap2_ce}</bes:constraint>
</bes:container>
EOF
)
    else
        container_element="${noConstraintContainerElement}"
    fi
    #echo "Container Element: " >&2
    #echo "${container_element}" >&2

    if test -n "${target_file}"; then
        #echo "Generate MISSING_FILE: ${target_file}"
        besGET_ELEMENT=$(
        cat <<EOF
</bes:define>
<bes:get type="${dap}" definition="d" returnAs="netcdf-4" />
</bes:request>
EOF
)
    else
        besGET_ELEMENT=$(
        cat <<EOF
</bes:define>
<bes:get type="${dap}" definition="d" />
</bes:request>
EOF
)
    fi

    d4BESCmd=$(
    cat <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<bes:request xmlns:bes="http://xml.opendap.org/ns/bes/1.0#" reqID="get_dmrpp.sh">
<bes:setContext name="dap_explicit_containers">no</bes:setContext>
<bes:setContext name="errors">xml</bes:setContext>
<bes:setContext name="max_response_size">0</bes:setContext>

<bes:setContainer name="c">${source_data_path}</bes:setContainer>

<bes:define name="d" space="default">
${container_element}
${besGET_ELEMENT}

EOF
)
    TEMP_FILE=$(mktemp -t dmr_XXXX)
    echo "${d4BESCmd}" >${TEMP_FILE}
    echo "${TEMP_FILE}"

    if test -n "${VERBOSE}"; then
        echo "      data_path: ${source_data_path}" >&2
        echo "        dap2_ce: '${dap2_ce}'" >&2
        echo "    ${dap}_request: ${TEMP_FILE} " >&2
        #echo " " >&2
    fi

    # ls -l ${TEMP_FILE}
    # cat ${TEMP_FILE}
}
########################################################################################################################

########################################################################################################################
# make_bes_conf()
#
# Prepare the bes.conf file - use external if provided otherwise use the here doc.
# Returns the bes conf file name on stdout.
#
function make_bes_conf() {

    if test -n "${1}"; then
        export BES_CONF_DOC=$(cat ${1})
    else
        mk_default_bes_conf
    fi

    if test -n "${2}"; then
        if test -n "${VERBOSE}"; then
            echo "Adding additional BES configuration from: ${2}" >&2
        fi
        export BES_CONF_DOC=$(echo "${BES_CONF_DOC}"; cat "${2}");
    fi
    #    echo "Using BES Configuration: " >&2
    #    echo "${BES_CONF_DOC}" >&2

    if test -n "${VERBOSE}"; then
        echo "Using BES Configuration: " >&2
        echo "${BES_CONF_DOC}" >&2
    fi

    local tmp_conf_file=$(mktemp -t conf_XXXX)
    echo "${BES_CONF_DOC}" > ${tmp_conf_file}


    if test -n "${VERY_VERBOSE}"; then
        echo "tmp_conf_file: ${tmp_conf_file}" >&2
        ls -l ${tmp_conf_file} >&2
        cat ${tmp_conf_file} >&2
    fi

    if test -n "${VERBOSE}"; then
        echo "       bes_conf: ${tmp_conf_file}" >&2
        if test -n "${2}"; then
            echo "      site_conf: ${2}" >&2
        fi
    fi

    echo "${tmp_conf_file}"
}
########################################################################################################################

########################################################################################################################
# getDap()
# Gets the passed $dap response (dmr, ddx, etc) for the file $data_path and places the response in a temp file.
#
function mkDapRequest() {
    local data_path="${1}"
    local dap="${2}"
    local dap_ce="${3}"
    local target_file="${4}"

    if test -n "${dap_ce}"; then
        DAP_CMD=$(mkDAP2BesCmd ${data_path} ${dap} ${dap_ce} ${target_file})
    else
        DAP_CMD=$(mkDAP2BesCmd ${data_path} ${dap})
    fi
    if test -n "${VERBOSE}"; then echo "        DAP_CMD: ${DAP_CMD}" >&2; fi

    if test -n "${target_file}"; then
        DAP_RESPONSE=$(echo "${BES_DATA_ROOT}"/"${target_file}")
    else
        DAP_RESPONSE=$(mktemp -t ${dap}_XXXX)
    fi
    if test -n "${VERBOSE}"; then echo "   DAP_RESPONSE: ${DAP_RESPONSE}" >&2; fi

    besstandalone -c ${BES_CONF} -i ${DAP_CMD} >${DAP_RESPONSE}
    status=$?
    if [ ${status} -ne 0 ]; then
        echo ""
        echo ""
        echo "!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!"
        echo "ERROR! The besstandalone program failed to build a ${dap} file!."
        echo "       The configuration is here: ${BES_CONF}"
        echo "             The command is here: ${DAP_CMD}"
        echo "The besstandalone output is here: ${DAP_RESPONSE}"
        exit 2
    fi

    if test -n "${VERY_VERBOSE}"; then
        echo "${dap}_response: ${DAP_RESPONSE} data_path: ${data_path}" >&2
    fi

    if test -n "${VERY_VERBOSE}"; then
        echo "DAP_RESPONSE: " >&2
        if test -z "${target_file}"; then
            cat ${DAP_RESPONSE} >&2
        fi
    fi

    # This is the return value of the function!
    echo "${DAP_RESPONSE}"

    #----------------------------------------------------------
    # I commented this out because it was screwing things up
    # to delete the configuration after the DMR was created but
    # before build_dmrpp had been run. ndp 11/01/21
    #
    # Clean up temporary files if not in debug mode
    #if test -z "${VERBOSE}"; then
    #echo "DAP_CMD: ${DAP_CMD}"
    #echo "BES_CONF: ${BES_CONF}"
    # rm -f ${DAP_CMD} ${BES_CONF}
    #  ;
    #fi
    #----------------------------------------------------------

}
########################################################################################################################

########################################################################################################################
# mk_dmrpp()
# Uses build_dmrpp application to build the requested dmr++ file.
#
function mk_dmrpp() {
    local datafile="${1}"
    local o_filename="${2}"

    full_data_path="${BES_DATA_ROOT}/${datafile}"

    if test -n "${VERBOSE}"; then
        echo "  BES_DATA_ROOT: ${BES_DATA_ROOT}"
        echo "       BES_CONF: ${BES_CONF} "
        echo "     SOURCE_DMR: ${SOURCE_DMR}"
        echo "      DMRPP_URL: ${DMRPP_URL}"
        echo "       datafile: ${datafile}"
        echo "o_filename: ${o_filename}"
        echo " full_data_path: ${full_data_path}"
    fi

    if test -z "${JUST_DMR}"; then
        prms="${VERY_VERBOSE}"
        prms="${prms} -c ${BES_CONF} "
        prms="${prms} -f ${full_data_path} "
        prms="${prms} -r ${SOURCE_DMR} "
        prms="${prms} -u ${DMRPP_URL} "
        prms="${prms} -M " # Adds the production metadata (version numbers and configuration) to the dmr++ result.
        if test -n "${VERBOSE}"; then echo "   build_params: ${prms}" >&2; fi
        if test -n "${o_filename}"; then
            build_dmrpp ${prms} > "${o_filename}"
        else
            build_dmrpp ${prms}
        fi
    else
        echo "The JUST_DMR flag is set, skipping dmr++ construction."
    fi

    #if test ! -n "${VERY_VERBOSE}" && test ! -n "${VERBOSE}"; then
    #echo "  mk_dmrpp:BES_CONF: ${BES_CONF}"
    #echo "mk_dmrpp:SOURCE_DMR: ${SOURCE_DMR}"
    #rm -f ${BES_CONF} ${SOURCE_DMR}
    #fi

    # TODO Use trap to ensure these are really removed
    # rm $DMR_CMD $SOURCE_DMR $TMP_CONF
}

#######################################################################################################################
# chk_dmrpp_for_missing_vars()
# Uses check_dmrpp application to identify missing variables in the requested dmr++ file.
#
function chk_dmrpp_for_missing_vars() {
    local dmrpp_file="${1}"
    local mvars_file="${2}"

    if test -n "${VERY_VERBOSE}"; then
        echo "     dmrpp_file: ${dmrpp_file}"
        echo "     mvars_file: ${mvars_file}"
    fi

    ck_prms="${dmrpp_file} ${mvars_file}"
    if test -n "${VERBOSE}"; then echo "   check_dmrpp parameters: ${ck_prms}"; fi
    if test -n "${mvars_file}"; then
        check_dmrpp ${ck_prms}
        return $?
    else
        echo "The missing_vars file wasn't specified, skipping missing variable construction."
        return 1
    fi
}
########################################################################################################################

###############################################################################
#
# BES Configuration elements to generate missing variable HDF5 sidecar file.
#

function make_missing_conf() {
    local missing_conf_elements=$(
    cat <<EOF
# Make sure this follows the netCDF-4 enhanced model
#
FONc.ClassicModel=false
#
# Don't generate global attributes since we only
# care about the variable value information.
#
FONc.NoGlobalAttrs=true
H5.ForceFlattenNDCoorAttr=true
H5.RmConventionAttrPath=true
#
# We don't map 64-bit integer to DMR
# to make it consistent with data value reading.
#
H5.EnableDMR64bitInt=false
#
# When the HDF5 storage size is zero, Fullnamepath
# attribute should not be generated for DMRPP to work.
#
H5.NoZeroSizeFullnameAttr=true
#
EOF
)

    if test -n "${1}"; then
        if test -n "${VERBOSE}"; then
            echo "Using Missing variable BES Configuration: \"${1}\""
        fi
        missing_conf_elements=$(cat ${1})
    else
        mk_default_bes_conf
    fi

    export BES_CONF_DOC=$(echo "${BES_CONF_DOC}"; echo "${missing_conf_elements}");

    local missing_bes_conf_file=$(mktemp -t conf_XXXX)

    echo "${BES_CONF_DOC}" >${missing_bes_conf_file}

    if test -n "${VERY_VERBOSE}"; then
        echo "missing_bes_conf_file: ${missing_bes_conf_file}" >&2
        ls -l ${missing_bes_conf_file} >&2
        cat ${missing_bes_conf_file} >&2
    fi

    echo "${missing_bes_conf_file}"

}
###############################################################################

#######################################################################################################################
# merge_dmrpp()
# Uses merge_dmrpp application to identify missing variables in the requested dmr++ file.
#
function mg_dmrpp() {
    local missing_vars_dmrpp_file="${1}"
    local master_dmrpp_file="${2}"
    local missing_data_url="${3}"
    local missing_vars_file="${4}"

    if test -n "${VERBOSE}"; then
        echo " missing_vars_dmrpp_file: ${missing_vars_dmrpp_file}"
        echo "       master_dmrpp_file: ${master_dmrpp_file}"
        echo "        missing_data_url: ${missing_data_url}"
        echo "       missing_vars_file: ${missing_vars_file}"
    fi

    mg_prms="${mg_prms} ${missing_vars_dmrpp_file} "
    mg_prms="${mg_prms} ${master_dmrpp_file} "
    mg_prms="${mg_prms} ${missing_data_url}"
    mg_prms="${mg_prms} ${missing_vars_file} "
    if test -n "${VERBOSE}"; then echo "   build_params: ${mg_prms}"; fi
    if test -n "$missing_vars_file"; then
        merge_dmrpp ${mg_prms}
        return $?
    else
        echo "The missing_vars file doesn't exist, there are no missing variables to merge."
        return 1
    fi
}
########################################################################################################################

#######################################################################################################################
# reduce_dmrpp()
# Uses reduce_dmrpp application to identify missing variables in the requested dmr++ file.
#
function reduce_dmrpp() {
    local missing_vars_data_file="${1}"
    local missing_vars_dmrpp_file="${2}"
    local master_sha256="${3}"
    local temporary_storage_file="${4}"

    local mvdf_full_path="${BES_DATA_ROOT}/${missing_vars_data_file}"

    if test -n "${VERBOSE}"; then
        echo "  missing_vars_data_file: ${missing_vars_data_file}"
        echo " missing_vars_dmrpp_file: ${missing_vars_dmrpp_file}"
        echo "          mvdf_full_path: ${mvdf_full_path}"
        echo "           master_sha256: ${master_sha256}"
        echo "  temporary_storage_file: ${temporary_storage_file}"
    fi

    rd_prms="${rd_prms} ${missing_vars_dmrpp_file} "
    rd_prms="${rd_prms} ${mvdf_full_path} "
    rd_prms="${rd_prms} ${master_sha256}"
    rd_prms="${rd_prms} ${temporary_storage_file} "
    if test -n "${VERBOSE}"; then echo "   build_params: ${rd_prms}"; fi
    if test -n "${missing_vars_dmrpp_file}"; then
        reduce_mdf ${rd_prms}
        return $?

    else
        echo "The missing_vars_dmrpp_file was not set exist, there are no missing variables to merge."
        return -1
    fi

}
########################################################################################################################

########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################

########################################################################################################################
# dap2_vars()
# Prints a list of DAP2 DDX variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap2_vars() {
    grep -e "<Byte" \
    -e "<Int" \
    -e "<UInt" \
    -e "<Float" \
    -e "<Float" \
    -e "<String" \
    -e "<URL" \
    -e "<Grid" \
    -e "<Sequence" \
    -e "<Structure" \
    -e "<Array" \
    "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap2_attributes()
# Prints a list of DAP2 DDX Attribute declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap2_attributes() {
    grep -e "<Attribute name=" -e "<Value>" "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap4_attributes()
# Prints a list of DAP4 DMR Attribute declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_attributes() {
    grep -e "<Attribute name=" -e "<Value>" "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_vars() {
    grep \
    -e "<Int8" \
    -e "<UInt8" \
    -e "<Byte" \
    -e "<Char" \
    -e "<Int" \
    -e "<UInt" \
    -e "<Float" \
    -e "<String" \
    -e "<URI" \
    -e "<Enumeration" \
    -e "<Sequence" \
    -e "<Structure" \
    -e "<Array" \
    -e "<Group" \
    -e "<Dimension" \
    "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_array_counter() {
    dmr_file=${1}
    type=${2}

    #echo "    dmr_file: ${dmr_file}" >&2;
    #echo "   DAP4 type: ${type}" >&2;

    cat "${dmr_file}" | awk -v type=${type} 'BEGIN{
    inVar = 0;
    typeMatchString = "^ *<"type;
    closeMatchString = "^ *</"type;
    match_count=0;
    }
    {
    if( match($0,typeMatchString)==1){
    inVar=1;
    match_count++;
    }
    if( inVar>0){
    if( match($0,closeMatchString)==1){
    inVar=0;
    }
    }
    }END{print match_count;}' -

}
########################################################################################################################

function dap4_array_dim_counter() {
    dmr_file=${1}
    type=${2}
    match_num="${3}"
    awk_params="-v type=${type} -v match_num=${match_num}"

    cat "${dmr_file}" | awk ${awk_params} 'BEGIN{
    inVar = 0;
    typeMatchString = "^ *<"type;
    # print "typeMatchString: " typeMatchString;
    closeMatchString = "^ *</"type
    # print "closeMatchString: " closeMatchString;
    target_dim_count=0;
    match_count=0;
    target_var_name="not found";
    }
    {
    if( match($0,typeMatchString)==1){
    inVar=1;
    match_count++;
    if(match_count==match_num){
    # <Float32 name="ClrOLR_A">
    target_var_name=$2;
    sub("name=\"","",target_var_name);
    sub("\">","",target_var_name);
    }
    }
    if( inVar>0){
    if(match_count==match_num &&  match($0,"^ *<Dim")==1  ){
    target_dim_count++;
    }
    else if( match($0,closeMatchString)==1){
    inVar=0;
    }
    }
    }END{ print target_var_name, target_dim_count; }' -

}
########################################################################################################################

########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_array_test() {
    dmr_file=${1}
    target_file=${2}
    type=${3}
    #echo "    dmr_file: ${dmr_file}" >&2;
    #echo " target_file: ${target_file}" >&2; 
    #echo "   DAP4 type: ${type}" >&2;

    var_count=$(dap4_array_counter ${dmr_file} ${type})
    if test -n "${VERBOSE}"; then echo "Found ${var_count} variables of type ${type} in DMR: ${dmr_file}" >&2; fi
    if [ ${var_count} -lt 1 ]; then
        echo "ERROR! No variables of type ${type} found in DMR!" >&2
        return 0
    fi

    pick_var=$(echo "${var_count}*${RANDOM}/32767+1" | bc)
    if test -n "${VERBOSE}"; then echo "Picked variable: ${pick_var}" >&2; fi

    name_and_dim=$(dap4_array_dim_counter ${dmr_file} ${type} ${pick_var})
    if test -n "${VERY_VERBOSE}"; then echo "name_and_dim: ${name_and_dim}" >&2; fi

    var_name=$(echo "${name_and_dim}" | awk '{print $1;}' -)
    if test -n "${VERY_VERBOSE}"; then echo "var_name: ${var_name}" >&2; fi

    var_dims=$(echo "${name_and_dim}" | awk '{print $2;}' -)
    if test -n "${VERY_VERBOSE}"; then echo "var_dims: ${var_dims}" >&2; fi

    query_string="${var_name}"
    for ((i = 1; i <= ${var_dims}; i++)); do
        query_string=${query_string}"[0]"
    done
    if test -n "${VERBOSE}"; then echo "   query_string: ${query_string}" >&2; fi

    bes_cmd_file=$(mkDAP2BesCmd "${INPUT_DATA_FILE}" "dods" "${query_string}")
    #if test -n "${VERBOSE}"; then echo "bes_cmd_file: ${bes_cmd_file}" >&2; fi
    dap2_source_response=$(mktemp -t d4_array_test_XXXX)
    besstandalone -c ${BES_CONF} -i ${bes_cmd_file} >${dap2_source_response}
    if test -n "${VERBOSE}"; then echo "dap2_source_response: ${dap2_source_response}" >&2; fi
    if test -n "${VERBOSE}"; then getdap -D -M ${dap2_source_response} >&2; fi

    if test -n "${VERY_VERBOSE}"; then
        echo "dap2_source_response: " >&2
        cat ${dap2_source_response} >&2
    fi

    bes_cmd_file=$(mkDAP2BesCmd "${target_file}" "dods" "${query_string}")
    #if test -n "${VERBOSE}"; then echo "bes_cmd_file: ${bes_cmd_file}" >&2; fi
    dap2_dmrpp_response=$(mktemp -t d4_array_test_XXXX)
    besstandalone -c ${BES_CONF} -i ${bes_cmd_file} >${dap2_dmrpp_response}
    if test -n "${VERBOSE}"; then echo "dap2_dmrpp_response: ${dap2_dmrpp_response}" >&2; fi
    if test -n "${VERBOSE}"; then getdap -D -M ${dap2_dmrpp_response} >&2; fi

    if test -n "${VERBOSE}"; then echo "Comparing binary responses..." >&2; fi
    cmp ${dap2_source_response} ${dap2_dmrpp_response} >&2
    if [ $? -eq 0 ]; then
        if test -n "${VERBOSE}"; then echo "Responses are the same. w00t" >&2; fi
        return 0
    else
        if test -n "${VERBOSE}"; then echo "ERROR! Responses differ." >&2; fi
        return 100
    fi

}

########################################################################################################################

########################################################################################################################
# compare_files()
# Compares two files by first applying the check_function to each file and then comparing the results of the
# check_function using diff.
#
function compare_files() {
    check_function=${1}
    first_file=${2}
    second_file=${3}
    success="${4}"
    failure="${5}"
    if test -n "${VERY_VERBOSE}"; then
        echo "compare_files() check_function: ${check_function}" >&2
        echo "compare_files()     first_file: ${first_file}" >&2
        echo "compare_files()    second_file: ${second_file}" >&2
    fi

    first_result=$(mktemp -t dmr_XXXX)
    if test -n "${VERY_VERBOSE}"; then
        echo "compare_files()   first_result: ${first_result}" >&2
    fi
    f_stuff=$(${check_function} ${first_file})
    echo "${f_stuff}" >${first_result}

    second_result=$(mktemp -t dmr_XXXX)
    if test -n "${VERY_VERBOSE}"; then
        echo "compare_files()  second_result: ${second_result}" >&2
    fi
    s_stuff=$(${check_function} ${second_file})
    echo "${s_stuff}" >${second_result}

    retval=0
    diff --ignore-space-change --brief ${first_result} ${second_result}
    if [ $? -eq 0 ]; then
        if test -n "${VERBOSE}"; then
            echo "${success}" >&2
        fi
    else
        echo "${failure}" >&2
        retval=1
    fi
    return ${retval}
}
########################################################################################################################

########################################################################################################################
# dmrpp_inventory_test()
#
function dmrpp_inventory_test() {
    local o_filename="${1}"
    if [[ ${o_filename} == ${BES_DATA_ROOT}* ]]; then
        target_file=$(echo "${o_filename}" | sed -e "s+${BES_DATA_ROOT}++")
    else
        test_file="${BES_DATA_ROOT}/"$(basename ${o_filename})
        if test ! -f ${testfile}; then
            cp ${o_filename} ${BES_DATA_ROOT}
        fi
        target_file=$(basename ${o_filename})
    fi

    if test -n "${EXISTING_DMRPP}"; then
        target_file="${EXISTING_DMRPP}"
    fi
    
    if test -n "${VERBOSE}"; then
        echo "       BES_CONF: ${BES_CONF}" >&2
        echo "INPUT_DATA_FILE: ${INPUT_DATA_FILE}" >&2
        echo "TARGET_DATAFILE: ${target_file}" >&2
    fi

    SOURCE_DDX=$(mkDapRequest "${INPUT_DATA_FILE}" ddx)
    TARGET_DDX=$(mkDapRequest "${target_file}" ddx)

    # SOURCE_DMR=$(mkDapRequest "${INPUT_DATA_FILE}" dmr) # This is done before the dmr++ file is built.
    TARGET_DMR=$(mkDapRequest "${target_file}" dmr)

    retval=0
    # echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap4_vars ${SOURCE_DMR} ${TARGET_DMR} " DAP4 variables: Matched." "ERROR! DAP4 variables mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap4_attributes ${SOURCE_DMR} ${TARGET_DMR} "DAP4 Attributes: Matched." "ERROR! DAP4 Attributes mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap2_vars ${SOURCE_DDX} ${TARGET_DDX} " DAP2 variables: Matched." "ERROR! DAP2 variables mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap2_attributes ${SOURCE_DDX} ${TARGET_DDX} "DAP2 Attributes: Matched." "ERROR! DAP2 Attributes mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    return ${retval}
}

########################################################################################################################
# dmrpp_value_test()
#
function dmrpp_value_test() {
    local o_filename="${1}"
    if test -z "${EXISTING_DMRPP}"; then
        target_file="${o_filename}"
    else
        target_file="${EXISTING_DMRPP}"
    fi
    
    if test -n "${VERY_VERBOSE}"; then
        echo "dvt        BES_CONF: ${BES_CONF}" >&2
        echo "dvt SOURCE_DATAFILE: ${INPUT_DATA_FILE}" >&2
        echo "dvt TARGET_DATAFILE: ${target_file}" >&2
        echo "dvt      SOURCE_DMR: ${SOURCE_DMR}" >&2
    fi
    for datatype in Int8 UInt8 Int16 UInt16 Int32 UInt32 Float32 Float64
    do
        dap4_array_test "${SOURCE_DMR}" "${target_file}" "${datatype}"
    done
    return $?
}


########################################################################################################################
# check_aws_config()
#
# Verify that the AWS CLI has been configured with credentials and default region
# Returns non-zero if the AWS CLI is not configured
#
function check_aws_config() {
    aws configure list | grep "access_key" | grep -v "<not set>" > /dev/null
    ret=$?
    if test $ret != 0 ; then
        echo "ERROR - The AWS_ACCESS_KEY_ID is not set."
        return $ret;
    fi
    aws configure list | grep "secret_key" | grep -v "<not set>" > /dev/null
    ret=$?
    if test $ret != 0 ; then
        echo "ERROR - The AWS_SECRET_ACCESS_KEY is not set."
        return $ret;
    fi
    aws configure list | grep "region" | grep -v "<not set>" > /dev/null
    ret=$?
    if test $ret != 0 ; then
        echo "WARNING - The AWS_DEFAULT_REGION is not set."
        return 0;
    fi
}


########################################################################################################################
# merge_missing()
#
# This function merges the missing variables (or not, depending on the state of
# the global MERGE_MISSING_VARS env var.)
#
function merge_missing() {
    if test -n "${MERGE_MISSING_VARS}"; then

        # use $PATH/check_dmrpp to query dmrpp for missing CF domain variables [requires ${OUTPUT_FILE}; -o option]
        missing_vars_file=$(mktemp -t missing_vars_XXXX)
        chk_dmrpp_for_missing_vars "${OUTPUT_FILE}" "${missing_vars_file}"
        retval=$(echo "${retval} + ${?}" | bc)
        #echo "retval: ${retval}";

        # check-dmrpp will write to the missing_vars_file if there are any missing variables.
        if test -s ${missing_vars_file}; then
            MISSING_VARS=$(cat ${missing_vars_file})
            if test -n "${VERY_VERBOSE}"; then echo "The missing vars: ${MISSING_VARS}" >&2; fi

            # augment BES_CONF_FILE with additional H5 parameters necessary to synthesize missing_variables from INPUT_DATA_FILE.
            BES_CONF=$(make_missing_conf "${BES_CONF_FILE}")

            # insert '_missing' into INPUT_DATA_FILE name and use for sidecar_missing_file name
            sidecar_missing_file="${INPUT_DATA_FILE}.missing"
            if test -n "${VERY_VERBOSE}"; then echo "  MISSING_FILE: ${sidecar_missing_file}" >&2; fi

            # use besstandalone to generate sidecar_missing_file
            MISSING_FILE_BESCMD=$(mkDapRequest "${INPUT_DATA_FILE}" dods "${MISSING_VARS}" "${sidecar_missing_file}")
            source_data_path="${sidecar_missing_file}"

            BES_CONF=$(make_bes_conf "${BES_CONF_FILE}" "${SITE_CONF_FILE}")  # reset BES_CONF_FILE; removing additional H5 parameters

            SOURCE_DMR=$(mkDapRequest "${sidecar_missing_file}" dmr)  # use besstandalone to generate dmr for sidecar_missing_file
            master_dmrpp_file="${OUTPUT_FILE}"  # save original dmrpp filename

            local missing_dmrpp_file=""
            if test -n "${REDUCE_MISSING_FILES}"; then
                if test ! -s ${MASTER_SHA256}; then
                    missing_dmrpp_file="${BES_DATA_ROOT}/${sidecar_missing_file}.dmrpp"
                else
                    missing_dmrpp_file=$(mktemp -t dmrpp_XXXX) # generate temporary dmrpp filename for sidecar_missing_file
                fi
            else
                missing_dmrpp_file=$(mktemp -t dmrpp_XXXX) # generate temporary dmrpp filename for sidecar_missing_file
            fi

            mk_dmrpp "${sidecar_missing_file}" "${missing_dmrpp_file}" # use $PATH/build_dmrpp to generate dmrpp for sidecar_missing_file
            retval=$?
            #echo "retval: ${retval}";

            if test -n "${REDUCE_MISSING_FILES}"; then
                local tempstore_file=$(mktemp -t tmpstore_XXXX) # generate temporary filename for tempstore to hold missing_dmrpp info
                if test -n "${VERY_VERBOSE}"; then
                    echo "missing_dmrpp_file: ${missing_dmrpp_file}" >&2;
                    echo " missing_vars_file: ${sidecar_missing_file}" >&2;
                    echo "     master_sha256: ${MASTER_SHA256}" >&2;
                    echo "         tempstore: ${tempstore_file}" >&2;
                fi

                # use $PATH/reduce_mdf to merge sidecar_missing_file dmrpp with master_dmrpp_file
                reduce_dmrpp "${sidecar_missing_file}" "${missing_dmrpp_file}" "${MASTER_SHA256}" "${tempstore_file}"
                retval=$?
                #echo "reduce_dmrpp: ${retval}"

                if test -s ${tempstore_file}; then # if tempstore_file is not empty then there will be temp that need to be removed.
                    temp_sidecar_dmrpp=${missing_dmrpp_file}
                    temp_sidecar_file="${BES_DATA_ROOT}/${sidecar_missing_file}"
                    missing_dmrpp_file=$(echo `awk -F'[ ]' '{print $2}' "${tempstore_file}"`)
                fi

            fi

            if test -n "${VERY_VERBOSE}"; then
                echo "missing_dmrpp_file: ${missing_dmrpp_file}" >&2;
                echo " master_dmrpp_file: ${master_dmrpp_file}" >&2;
                echo "       target_path: ${target_path}" >&2;
                echo " missing_vars_file: ${missing_vars_file}" >&2;
            fi

            # set 'href' content to use when merging chunks from sidecar_missing_file dmrpp into master_dmrpp_file
            local missing_data_url_path="OPeNDAP_DMRpp_MISSING_DATA_ACCESS_URL"
            if test -n "${MISSING_DATA_HREF}"; then
                missing_data_url_path="${MISSING_DATA_HREF}"
            fi
            # use $PATH/merge_dmrpp to merge sidecar_missing_file dmrpp with master_dmrpp_file
            mg_dmrpp  "${missing_dmrpp_file}" "${master_dmrpp_file}" "${missing_data_url_path}" "${missing_vars_file}"
            retval=$(echo "${retval} + ${?}" | bc)
            #echo "retval: ${retval}"

        else
            echo " There are no missing variables to merge."
        fi
    fi
}

########################################################################################################################
# run_tests()
#
# This function conditionally runs the dmr++ sanity checking tests
#
function run_tests(){
    local o_filename="${1}"

    if test -n "${RUN_INVENTORY_TESTS}"; then
        dmrpp_inventory_test "${o_filename}"
        retval=$(echo "${retval} + ${?}" | bc)
        #echo "dmrpp_inventory_test: retval: ${retval}"
    fi

    if test -n "${RUN_VALUE_TESTS}"; then
        dmrpp_value_test "${o_filename}"
        retval=$(echo "${retval} + ${?}" | bc)
        #echo "retval: ${retval}";
    fi
}

########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
#
# main() (such as it is in bashlandia)
#
#
#
trap cleanup_temp_files EXIT

# Here we test to see if the input file name is actually an S3 URL
# and if it is we adjust the INPUT_DATA_FILE and go out and get the
# object from S3.
s3_granule=
if [[ "${INPUT_DATA_FILE}" =~ ^s3:\/\/.* ]]
then
    s3_granule="${INPUT_DATA_FILE}"
    echo "Detected S3 URL as data input: ${s3_granule}" >&2

    set +e
    check_aws_config
    ret=$?
    if test $ret != 0
    then
        echo "ERROR - The AWS CLI is not configured. Exiting." >&2
        exit 1
    fi

    INPUT_DATA_FILE=$(basename "${s3_granule}")
    echo "INPUT_DATA_FILE: ${INPUT_DATA_FILE}" >&2

    local_file=""
    if test "${BES_DATA_ROOT}" = "/"; then # TODO - This should test for ends_with("/")
        local_file="/${INPUT_DATA_FILE}"
    else
        local_file="${BES_DATA_ROOT}/${INPUT_DATA_FILE}"
    fi
    echo "Copying S3 object to: ${local_file}" >&2

    aws s3 cp ${s3_granule} ${local_file}
    result=$?
    if test $result != 0
    then
        echo "ERROR - Failed to acquire S3 object. (status: $result) Exiting..." >&2
        exit $result
    fi

    set -e
fi


BES_CONF=$(make_bes_conf "${BES_CONF_FILE}" "${SITE_CONF_FILE}")
SOURCE_DMR=$(mkDapRequest "${INPUT_DATA_FILE}" dmr)

# If 'JUST_DMR' is set redirect SOURCE_DMR to either <stdout> or $OUTPUT_FILE
if test -n "${JUST_DMR}" ; then
    if test -z "${OUTPUT_FILE}" ; then
        cat ${SOURCE_DMR} >&2
    else
        cat ${SOURCE_DMR} >${OUTPUT_FILE};
    fi
    if test -z "${VERBOSE}"; then
        rm -f ${SOURCE_DMR}
    fi
    exit 0
fi


mk_dmrpp "${INPUT_DATA_FILE}" "${OUTPUT_FILE}"
retval=$?
#echo "retval: ${retval}";
if test -n "${VERBOSE}"; then echo "main() - TEMP_FILE_LIST: ${TEMP_FILE_LIST}" >&2; fi


if test -z "${VERBOSE}"; then
    #if test -f "${BES_CONF}" ; then rm -f "${BES_CONF}"; fi
    if test -f "${DAP_CMD}" ; then rm -f "${DAP_CMD}"; fi
fi

# Merge the missing variable data (conditional)
merge_missing

# Run the dmr++ tests (conditional)
run_tests "${OUTPUT_FILE}"

# Push the dmr++ to S3 target (conditional)
if test -n "${s3_granule}" && test -n "${S3_UPLOAD}"
then
    if test -z "${OUTPUT_FILE}"
    then
        echo "#---------------------------------------------------------------------" >&2
        echo "ERROR - Unable to upload dmr++ file because the output file name has not been set!" >&2
        echo "        Use the -o parameter. To set the output file name" >&2
        echo "-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -" >&2
        show_usage >&2
        echo "#---------------------------------------------------------------------" >&2
        exit 1
    fi
    s3_dmrpp="${s3_granule}.dmrpp"
    echo "Uploading dmr++ file (${OUTPUT_FILE}) to: ${s3_dmrpp}" >&2
    set +e
    aws s3 cp "${OUTPUT_FILE}" "${s3_dmrpp}"
    result=$?
    if test $result != 0
    then
        echo "ERROR - Failed to upload S3 object. Exiting..." >&2
        exit 1
    fi
    set -e
fi


# Cleanup the mess, or not (conditional)
if test -z "${VERBOSE}"; then
    if test -n "${MERGE_MISSING_VARS}"; then
        echo "    main:MISSING_VARS_FILE: ${missing_vars_file}"
        echo " main:SIDECAR_MISSING_FILE: ${temp_sidecar_file}"
        echo "main:SIDECAR_MISSING_DMRPP: ${temp_sidecar_dmrpp}"
        echo "       main:TEMPSTORE_FILE: ${tempstore_file}"
        rm -f ${missing_vars_file} ${temp_sidecar_file} ${temp_sidecar_dmrpp} ${tempstore_file}
    fi
    #echo " main:SOURCE_DMR: ${SOURCE_DMR}"
    rm -f ${SOURCE_DMR} ${BES_CONF}
fi

#echo "retval: ${retval}";
exit $retval

# rm -f ${SOURCE_DMR} ${SOURCE_DDX} ${TARGET_DDX} ${TARGET_DMR} ${DDX_CMD} ${DMR_CMD} ${BES_CONF}

#./get_dmrpp -u "http://test.opendap.org/data/dmrpp/AIRS.2015.01.01.L3.RetStd_IR001.v6.0.11.0.G15013155825.nc.h5" -o airs.h5.dmrpp -T -v  airs.h5
#./get_dmrpp -u "http://test.opendap.org/data/dmrpp/SMAP_L3_SM_P_20150406_R14010_001.h5" -o smap.h5.dmrpp -T -v  smap.h5
