#!/bin/bash
#set -e;

###############################################################################
#
# Default data root for BES
#
data_root=`pwd`;


###############################################################################
#
# Default BES Configuration.
#
BES_CONF_DOC=`cat <<EOF 
# This configuration file is read by besstandalone when it is used to 
# produce DMR documents for use with build_dmrpp. The DAP, XML Command
# and HDF5 handler modules are the 'installed' ones (not the modules
# found in the build tree). jhrg 5/11/18

BES.ServerAdministrator=admin.email.address@your.domain.name

BES.User=user_name
BES.Group=group_name

BES.LogName=./bes.log
BES.LogVerbose=no

BES.modules=dap,cmd,h5,dmrpp

# Despite the comment at the top, use the development modules for now. jhrg 5/11/18

# BES.module.dap=@modulesdir@/libdap_module.so
# BES.module.cmd=@modulesdir@/libdap_xml_module.so
# BES.module.h5=@modulesdir@/libhdf5_module.so

BES.module.dap=@abs_top_builddir@/dap/.libs/libdap_module.so
BES.module.cmd=@abs_top_builddir@/xmlcommand/.libs/libdap_xml_module.so
BES.module.h5=@abs_top_builddir@/modules/hdf5_handler/.libs/libhdf5_module.so
BES.module.dmrpp=@abs_top_builddir@//modules/dmrpp_module/.libs/libdmrpp_module.so

# The value "@hdf5_root_directory@" is replaced at run time.
BES.Catalog.catalog.RootDirectory=@hdf5_root_directory@
BES.Data.RootDirectory=/dev/null

BES.Catalog.catalog.TypeMatch=h5:.*\.(h5|he5|nc4)(\.bz2|\.gz|\.Z)?$;
BES.Catalog.catalog.TypeMatch+=dmrpp:.*\.(dmrpp)$;

BES.Catalog.catalog.Include=;
BES.Catalog.catalog.Exclude=^\..*;

BES.FollowSymLinks=Yes
BES.Catalog.catalog.FollowSymLinks=Yes

BES.Info.Buffered=no
BES.Info.Type=xml

BES.UncompressCache.dir=/tmp/hyrax_ux
BES.UncompressCache.prefix=ux_
BES.UncompressCache.size=500
BES.Uncompress.Retry=2000
BES.Uncompress.NumTries=10

BES.Container.Persistence=strict

BES.Memory.GlobalArea.EmergencyPoolSize=1
BES.Memory.GlobalArea.MaximumHeapSize=20
BES.Memory.GlobalArea.Verbose=no
BES.Memory.GlobalArea.ControlHeap=no

BES.ProcessManagerMethod=multiple

BES.DefaultResponseMethod=POST

# Control the Metadata Response Store. Here, DAP metadata responses
# are stored/cached so that they can be returned by the server w/o
# having to touch the data files/objects. Setting the 'path' to null
# disables uses of the MDS. Setting 'size' to zero makes the MDS
# hold objects forever; setting a positive non-zero size makes the
# MDS behave like a cache, purging responses when the size is exceeded.

# FIXME This will need to be modified for the DMR++ responses when
# when enable Arch #2 since regenerating the DMR++ will be more
# expensive than regenerating other responses from files

DAP.GlobalMetadataStore.path = @abs_top_builddir@/modules/dmrpp_module/data/mds
DAP.GlobalMetadataStore.prefix = mds
DAP.GlobalMetadataStore.size = 0

# The MDS writes a ledger of additions and removals. By default the
# ledger is kept in 'mds_ledger.txt' in the directory used to start
# the BES.

DAP.GlobalMetadataStore.ledger = @abs_top_builddir@/modules/dmrpp_module/data/mds_ledger.txt

#-----------------------------------------------------------------------#
# HDF5 handler specific parameters: 
#-----------------------------------------------------------------------#
# EnableCF: Handle HDF data to follow the CF conventions
#   (true,yes|false,no, defaults to false)
# Since most centers  would like to handle HDF5 data that follows CF now,
# I set the EnableCF to be true, KY 2011-8-4
#
H5.EnableCF=true
H5.KeepVarLeadingUnderscore=false
H5.EnableCheckNameClashing=true
H5.EnableAddPathAttrs=true
H5.EnableDropLongString=true
H5.DisableStructMetaAttr=true
H5.EnableFillValueCheck=true
H5.CheckIgnoreObj=false
H5.MetaDataMemCacheEntries=300
H5.LargeDataMemCacheEntries=0
H5.SmallDataMemCacheEntries=0 
#H5.CachePurgeLevel=0.2

H5.EnableDiskMetaDataCache=false
H5.EnableDiskDDSCache=false
H5.DiskMetaDataCachePath=/tmp

H5.EnableEOSGeoCacheFile=false
H5.Cache.latlon.path=/tmp/latlon
H5.Cache.latlon.prefix=l
H5.Cache.latlon.size=20000

H5.EnableDiskDataCache=false
H5.DiskCacheDataPath=/tmp
H5.DiskCacheFilePrefix=c
H5.DiskCacheSize=10000
H5.DiskCacheComp=true
H5.DiskCacheFloatOnlyComp=true
H5.DiskCacheCompThreshold=2.0
H5.DiskCacheCompVarSize=10000
EOF
`
###############################################################################



###############################################################################
#
# Print the usage information.
#
show_usage() {
    cat <<EOF

 Usage: $0 [options] <hdf5 file>

 Write the DMR++ for hdf5_file to stdout

 By default the BES Data Root directory is set to the CWD. This
 utility will add an entry to the bes.log specified in the
 configuration file. The DMR++ is built using the DMR as returned
 by the HDF5 handler, using options as set in the bes
 configuration file found here.

 -h: Show help
 -v: Verbose: Print the DMR too
 -V: Very Verbose: print the DMR, the command and the configuration
     file used to build the DMR
 -r: Just print the DMR that will be used to build the DMR++
 -u: The binary object URL for use in the DMR++ file
 -d: Data root directory for the BES.
 -c: The path to the bes configuration file to use.
 -o: The name of the file  to create.
 -T: Run hyrax tests on the resulting dmr++ file and compare the responses
     the ones generated by the source hdf5 file.

 Limitations: 
 * The pathanme to the hdf5 file must be relative from the
   directory where this command was run; absolute paths will not work.
 * The build_dmrpp command must be in the CWD.
 * The bes conf template has to build by hand. jhrg 5/11/18
EOF
}

OPTIND=1        # Reset in case getopts has been used previously in this shell

verbose=
very_verbose=
just_dmr=
dmrpp_url=
bes_conf_file=
run_tests=

while getopts "h?vVru:d:o:c:T" opt; do
    case "$opt" in
    h|\?)
        show_usage
        exit 0
        ;;
    v)
        verbose="yes"
        echo "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -";
        echo "${0} - BEGIN (verbose)";
        ;;
    V)
        very_verbose="-v"
        verbose="yes"
        echo "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -";
        echo "${0} - BEGIN (very_verbose)";
       ;;
    c) 
        bes_conf_file="$OPTARG"
        ;;
    r)
        just_dmr="yes"
        ;;
    u)
        dmrpp_url="$OPTARG"
        ;;
    d)
        data_root="$OPTARG"
        ;;
    o)
        output_file="$OPTARG"
        ;;
    T)
        run_tests="yes"
        ;;
    esac
done

shift $((OPTIND-1))

[ "$1" = "--" ] && shift

if test -n "$very_verbose"
then
    set -x;
fi

input_data_file="${1}";

if test -z "${output_file}"
then
    output_file="./get_dmrpp_result.dmrpp"
fi

if test -n "${verbose}"
then
	echo "    OUTPUT_FILE: ${output_file}";
	echo -n "       just_dmr: ";
	if test -n "$just_dmr";
	then
	  echo "true";
  else
    echo "false";
  fi
	echo "      dmrpp_url: ${dmrpp_url}";
fi

if test -z "${dmrpp_url}"
then
	echo "ERROR! You must supply a dmrpp_url value using the -u option." >&2
    show_usage
	exit 666
fi

########################################################################################################################
# mkBesCmd()
# Creates a BES request document for the $dap_thing (dmr, ddx, etc)
# from the $source_data_path file and sticks the command in a temp file.
#
function mkBesCmd() {
  dap=${1};
  source_data_path="${2}";
 BESCmd=`cat <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<bes:request xmlns:bes="http://xml.opendap.org/ns/bes/1.0#" reqID="get_dmrpp.sh">
  <bes:setContext name="dap_explicit_containers">no</bes:setContext>
  <bes:setContext name="errors">xml</bes:setContext>
  <bes:setContext name="max_response_size">0</bes:setContext>

  <bes:setContainer name="c">${source_data_path}</bes:setContainer>

  <bes:define name="d" space="default">
    <bes:container name="c">
    </bes:container>
  </bes:define>

  <bes:get type="${dap}" definition="d" />

</bes:request>

EOF
`
  TEMP_FILE=$(mktemp -t dmr_XXXX)
  echo "${BESCmd}" > ${TEMP_FILE}
  echo "${TEMP_FILE}"

  if test -n "$very_verbose"
	then
    echo "${dap}_request: ${TEMP_FILE} data_path: ${source_data_path}" >&2
    # echo " " >&2
  fi

  # ls -l ${TEMP_FILE}
  # cat ${TEMP_FILE}
}
########################################################################################################################







########################################################################################################################
# Prepare the bes.conf file - use external if provided otherwise use the here doc.
#
function make_bes_conf() {

  if  test -n "${1}"
	then
		if test -n "${verbose}"; then
		   echo "Using BES Configuration: \"${1}\"";
		fi
		BES_CONF_DOC=`cat ${1}`;
	fi

	TMP_CONF=$(mktemp -t conf_XXXX)
	# Use the $data_root as the BES Data Root directory - this is a trick so that the
	# script can get a DMR using the HDF5 handler algorithm, as tweaked by the
	# handlers configuration parameters in the BES_CONF_DOC here document.
	echo  "${BES_CONF_DOC}" | sed -e "s%[@]hdf5_root_directory[@]%${data_root}%" > ${TMP_CONF};

	if test -n "$very_verbose"
	then
	    echo "TMP_CONF: ${TMP_CONF}" >&2
	    ls -l ${TMP_CONF} >&2
	    cat ${TMP_CONF} >&2
	fi

  echo "${TMP_CONF}"
  unset TMP_CONF;
}
########################################################################################################################





########################################################################################################################
# getDap()
# Gets the passed $dap response (dmr, ddx, etc) for the file $data_path and places the reponse in a temp file.
#
function getDap() {
  dap=${1};
  data_path="${2}";
  DAP_CMD=`mkBesCmd ${dap} "${data_path}"`
  DAP_RESPONSE=$(mktemp -t dmr_XXXX)
  besstandalone -c ${BES_CONF} -i ${DAP_CMD} > ${DAP_RESPONSE}
  echo "${DAP_RESPONSE}"

  if test -n "$very_verbose"
	then
    echo "${dap}_response: ${DAP_RESPONSE} data_path: ${data_path}" >&2
  fi

	if test -n "$very_verbose"
	then
    echo "DAP_RESPONSE: " >&2
    cat ${DAP_RESPONSE} >&2
	fi
}
########################################################################################################################



########################################################################################################################
# mk_dmrpp()
# Uses build_dmrpp application to build the requested dmr++ file.
#
function mk_dmrpp() {
    datafile="${1}";
	full_data_path="${data_root}/${datafile}";
	if test -n "$verbose"
	then
	    echo "      data_root: ${data_root}"
	    echo "       datafile: ${datafile}"
	    echo " full_data_path: ${full_data_path}"
	fi
	if test -z "${just_dmr}"
	then
      build_dmrpp ${very_verbose} -c "${BES_CONF}" -f "${full_data_path}" -r "${TMP_DMR_RESP}" -u "${dmrpp_url}" > "${output_file}";
	else
	    echo "The just_dmr flag is set, skipping dmr++ construction."
	fi
	
	# TODO Use trap to ensure these are really removed
	# rm $DMR_CMD $TMP_DMR_RESP $TMP_CONF
}
########################################################################################################################

########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################


########################################################################################################################
# dap2_vars()
# Prints a list of DAP2 DDX variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap2_vars() {
  grep -e "<Byte" \
        -e "<Int" \
        -e "<UInt" \
        -e "<Float" \
        -e "<Float" \
        -e "<String" \
        -e "<URL" \
        -e "<Grid" \
        -e "<Sequence" \
        -e "<Structure" \
        -e "<Array" \
  "${1}" |  sed 's/ *$//g' | sort
}
########################################################################################################################


########################################################################################################################
# dap2_attributes()
# Prints a list of DAP2 DDX Attribute declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap2_attributes() {
  grep -e "<Attribute name=" -e "<value>" "${1}" |  sed 's/ *$//g' | sort
}
########################################################################################################################


########################################################################################################################
# dap4_attributes()
# Prints a list of DAP4 DMR Attribute declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_attributes() {
  grep -e "<Attribute name=" -e "<Value>" "${1}" |  sed 's/ *$//g' | sort;
}
########################################################################################################################


########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_vars() {
  grep \
    -e "<Byte" \
    -e "<Int" \
    -e "<UInt" \
    -e "<Float" \
    -e "<Float" \
    -e "<String" \
    -e "<URI" \
    -e "<Enumeration" \
    -e "<Sequence" \
    -e "<Structure" \
    -e "<Array" \
    -e "<Group"  \
    -e "<Dimension" \
  "${1}" |  sed 's/ *$//g' | sort
}
########################################################################################################################


########################################################################################################################
# compare_files()
# Compares two files by first applying the check_function to each file and then comparing the results of the
# check_function using diff.
#
function compare_files(){
  check_function=${1};
  first_file=${2};
  second_file=${3};
  success="${4}";
  failure="${5}";
  if test -n "$very_verbose"
  then
    echo "compare_files() check_function: ${check_function}" >&2
    echo "compare_files()     first_file: ${first_file}" >&2
    echo "compare_files()    second_file: ${second_file}" >&2
  fi

  first_result=$(mktemp -t dmr_XXXX)
  if test -n "$very_verbose"
  then
    echo "compare_files()   first_result: ${first_result}" >&2
  fi
  f_stuff=`${check_function}  ${first_file}`
  echo "${f_stuff}" > ${first_result}

  second_result=$(mktemp -t dmr_XXXX)
  if test -n "$very_verbose"
  then
    echo "compare_files()  second_result: ${second_result}" >&2
  fi
  s_stuff=`${check_function} ${second_file}`
  echo "${s_stuff}" > ${second_result}

  retval=0;
  diff --ignore-space-change --brief ${first_result} ${second_result}
  if [ $? -eq 0 ]
  then
    if test -n "${verbose}"
    then
      echo "${success}" >&2
    fi
  else
    echo "${failure}" >&2
    retval=1
  fi
  return ${retval};
}
########################################################################################################################


########################################################################################################################
# dmrpp_inventory_test()
#
function dmrpp_inventory_test(){
  if test -n "${verbose}"
  then
    echo "       BES_CONF: ${BES_CONF}" >&2
    echo "SOURCE_DATAFILE: ${input_data_file}" >&2
    echo "TARGET_DATAFILE: ${output_file}" >&2
  fi

  SOURCE_DDX=`getDap ddx "${input_data_file}"`
  TARGET_DDX=`getDap ddx "${output_file}"`

  SOURCE_DMR=`getDap dmr "${input_data_file}"`
  TARGET_DMR=`getDap dmr "${output_file}"`

  compare_files dap4_vars ${SOURCE_DMR} ${TARGET_DMR} " DAP4 variables: Matched." "ERROR! DAP4 variables mismatch!"
  compare_files dap4_attributes ${SOURCE_DMR} ${TARGET_DMR} "DAP4 Attributes: Matched." "ERROR! DAP4 Attributes mismatch!"

  compare_files dap2_vars ${SOURCE_DDX} ${TARGET_DDX} " DAP2 variables: Matched." "ERROR! DAP2 variables mismatch!"
  compare_files dap2_attributes ${SOURCE_DDX} ${TARGET_DDX} "DAP2 Attributes: Matched." "ERROR! DAP2 Attributes mismatch!"

}

########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################

BES_CONF=`make_bes_conf "${bes_conf_file}"`
TMP_DMR_RESP=`getDap dmr "${input_data_file}"`;
mk_dmrpp "${input_data_file}";
retval=$?

if test -n "${run_tests}"
then
    dmrpp_inventory_test
    retval=$?
fi
exit $retval

# rm -f ${SOURCE_DMR} ${SOURCE_DDX} ${TARGET_DDX} ${TARGET_DMR} ${DDX_CMD} ${DMR_CMD} ${BES_CONF}
