#!/bin/bash
set -e
#set -x;

GET_DMRPP_VERSION="get_dmrpp-@get_dmrpp_version@";


###############################################################################
#
# Print the usage information.
#
function show_usage() {
    echo ""
    echo " [${GET_DMRPP_VERSION}]"
    cat <<EOF

Usage: $0 [options] <INPUT_DATA_FILE>

Write the DMR++ for INPUT_DATA_FILE (a hdf5/netcdf file) to stdout

* By default the BES Data Root directory is set to /tmp.
* This utility will add an entry to the bes.log specified in the
configuration.
* The DMR++ is built using the DMR as returned by the HDF5 handler
when invoked using options as set in the bes configuration the included
BES configuration as modified by the -s option or using the BES
configuration supplied with the -c option, see below.

-h: Show help
-z: Show version information (Verbose got here first.)
-v: Verbose: Print the DMR too
-V: Very Verbose: print the DMR, the command and the configuration
    file used to build the DMR, and do not remove temporary files.
-D: Just print the DMR that will be used to build the DMR++
-u: The binary object URL for use in the DMR++ file. If option '-u' is
    not used; then dap4:Dataset/@dmrpp:href attribute will contain the template string
    OPeNDAP_DMRpp_DATA_ACCESS_URL which can be replaced at runtime.
-b: The fully qualified path to the BES_DATA_ROOT directory. May not be "/" or "/etc".
    The default value is /tmp if a value is not provided
-c: The path to the bes configuration file to use.
-s: The path to an optional addendum configuration file which will be appended to the
    default BES configuration. Much like the site.conf file works for the full server
    deployment it will be loaded last and the settings there-in will have an override
    effect on the default configuration.
-o: The name of the dmr++ file to create. This is required when using -U so that the
    AWS CLI component has a file to transfer.
-e: The name of pre-existing dmr++ file to test.
-T: Run ALL hyrax tests on the resulting dmr++ file and compare the responses
    the ones generated by the source hdf5 file.
-I: Run hyrax inventory tests on the resulting dmr++ file and compare the responses
    the ones generated by the source hdf5 file.
-F: Run hyrax value probe tests on the resulting dmr++ file and compare the responses
    the ones generated by the source hdf5 file.
-M: Create and merge missing CF coordinate domain variables into the dmrpp. If there are
    missing variables, a sidecar file named <INPUT_DATA_FILE>.missing will be created
    in the same directory location as the INPUT_DATA_FILE.
    If option 'p' is not used; missing variable chunk href will contain OPeNDAP_DMRpp_MISSING_DATA_ACCESS_URL.
    If option 'p' is selected; missing variable chunk href will contain the argument provided to that option
-p: The value to use for each missing variable's dmrpp:chunk/@dmrpp:href attribute.  If option '-p' is
    not used; the missing variable dmrpp:chunk/@dmrpp:href attributes will contain the template string
    OPeNDAP_DMRpp_MISSING_DATA_ACCESS_URL which can be replaced at runtime.
-r: The path to the file that contains missing variable information for sets of input data files that share
    common missing variables. The file will be created if it doesn't exist and the result may be used in subsequent
    invocations of get_dmrpp (using -r) to identify the missing variable file.
-U: If present, and if the input data file is an AWS S3 URL (s3://...), and if the output data file has been set (using
    the -o option) the presence of this parameter will cause get_dmrpp to copy the finished dmr++ file to the same S3
    bucket location as the input data file. This must be used in conjunction with the -o switch as a local file is
    required before it can be transferred to S3.
-A: If present will cause the tool to use the "build" versions of the various component libraries as opposed to the
    nominal "install" version. This option is used by the autotest (aka make check/distcheck) targets for testing
    against builds that have not been installed.

Limitations:
* The name of the hdf5 file must be expressed relative to the BES_DATA_ROOT, or as an S3 URL (s3://...)

EOF
}

OPTIND=1 # Reset in case getopts has been used previously in this shell

VERBOSE=
VERY_VERBOSE=
JUST_DMR=
DMRPP_URL=
BES_CONF_FILE=
SITE_CONF_FILE=
RUN_INVENTORY_TESTS=
RUN_VALUE_TESTS=
MERGE_MISSING_VARS=
OUTPUT_FILE=
REDUCE_MISSING_FILES=
MASTER_SHA256=
BES_DATA_ROOT="/tmp"
EXISTING_DMRPP=
S3_UPLOAD=
USE_AUTOMAKE_LIBS=
CLEANUP_TEMP_FILES="true"
export TEMP_FILE_LIST=""

while getopts "h?vVDu:o:c:b:s:p:r:e:zTIFMUAX" opt; do
    case "$opt" in
    h | \?)
        show_usage >&2
        exit 0
        ;;
    z)
        echo "${GET_DMRPP_VERSION}" >&2
        exit 0
        ;;
    A)
        USE_AUTOMAKE_LIBS="true"
        ;;
    v)
        VERBOSE="yes"
        echo "# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -" >&2
        echo "# ${0} - BEGIN (VERBOSE)" >&2
        ;;
    V)
        VERY_VERBOSE="-v"
        VERBOSE="yes"
        echo "# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -" >&2
        echo "# ${0} - BEGIN (VERY_VERBOSE)" >&2
        ;;
    c)
        BES_CONF_FILE="$OPTARG"
        ;;
    s)
        SITE_CONF_FILE="$OPTARG"
        ;;
    b)
        BES_DATA_ROOT="$OPTARG"
        ;;
    M)
        MERGE_MISSING_VARS="yes"
        ;;
    p)
        MISSING_DATA_HREF="$OPTARG"
        ;;
    r)
        MASTER_SHA256="$OPTARG"
        REDUCE_MISSING_FILES="yes"
        ;;
    D)
        JUST_DMR="yes"
        ;;
    u)
        DMRPP_URL="$OPTARG"
        ;;
    o)
        OUTPUT_FILE="$OPTARG"
        ;;
    T)
        RUN_INVENTORY_TESTS="yes"
        RUN_VALUE_TESTS="yes"
        ;;
    I)
        RUN_INVENTORY_TESTS="yes"
        ;;
    F)
        RUN_VALUE_TESTS="yes"
        ;;
    e)
        EXISTING_DMRPP="$OPTARG"
        ;;
    U)
        S3_UPLOAD="yes"
        ;;
    X)
        CLEANUP_TEMP_FILES=
        ;;
    esac
done

shift $((OPTIND - 1))
[ "$1" = "--" ] && shift

if test -n "${VERY_VERBOSE}"; then
    set -x
fi

INPUT_DATA_FILE="${1}"

if test -n "${VERBOSE}"; then
    echo "#    OUTPUT_FILE: ${OUTPUT_FILE}" >&2
    echo -n "#       JUST_DMR: " >&2
    if test -n "${JUST_DMR}"; then
        echo "true" >&2
    else
        echo "false" >&2
    fi
    echo "#      DMRPP_URL: ${DMRPP_URL}" >&2
fi

if test -z "${DMRPP_URL}"; then
    DMRPP_URL="OPeNDAP_DMRpp_DATA_ACCESS_URL"
    echo "# Using Template Data Access URL String: '${DMRPP_URL}'" >&2
fi

# If we are running tests then we need to have the output filename for the dmr++ content.
if [ -n "${RUN_INVENTORY_TESTS}" ] || [ -n "${RUN_VALUE_TESTS}" ]; then
    if [ -z "${OUTPUT_FILE}" ] && [ -z "${EXISTING_DMRPP}" ]; then
        echo "" >&2
        echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
        echo "" >&2
        echo "OUCH! In order to run the tests the dmr++ output must be written to a file using the -o option. " >&2
        echo "" >&2
        exit 1
    fi
fi

# If we are merging missing variables then we need to have the output filename for the dmr++ content.
if [ -n "${MERGE_MISSING_VARS}" ]; then
    if [ -z "${OUTPUT_FILE}" ]; then
        echo "" >&2
        echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
        echo "" >&2
        echo "OUCH! In order to merge missing variables the dmr++ output must be written to a file using the -o option. " >&2
        echo "" >&2
        exit 1
    fi
fi

###############################################################################
#
# cleanup_temp_files()
#
# Conditionally cleans up the list of temporary files created during the
# execution of this script.
# subshell: NEVER
#
function cleanup_temp_files(){
    if test -n "${CLEANUP_TEMP_FILES}"
    then
        echo "########################################################################" >&2
        echo "# cleanup_temp_files()" >&2
        echo "#" >&2
        echo "# TEMP_FILE_LIST: ${TEMP_FILE_LIST}" >&2;
        rm -vf ${TEMP_FILE_LIST} >&2
        echo "# Temporary files have been removed." >&2;
    fi
}

###############################################################################
#
# make_temp_file()
# subshell: NEVER
#
#
function make_temp_file(){
    local file_prefix="${1}"

    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
        echo "# make_temp_file()" >&2
        echo "#     file_prefix: ${file_prefix}" >&2;
    fi

    local tmp_file=""
    tmp_file=$(mktemp "/tmp/${file_prefix}_XXXXXX")
    local retval=$?
    if test $? -ne 0
    then
        echo "ERROR: Failed to create temporary file. prefix: ${file_prefix}" >&2
        return $retval;
    fi
    if test -n "${VERBOSE}"; then echo "# tmp_file: ${tmp_file}" >&2; fi

    export TEMP_FILE_LIST="${TEMP_FILE_LIST} ${tmp_file}"
    if test -n "${VERBOSE}"; then echo "# TEMP_FILE_LIST: ${TEMP_FILE_LIST}" >&2; fi

    echo "${tmp_file}"
    export TEMP_FILE="${tmp_file}"
    return 0
}



###############################################################################
#
# mk_automake_conf()
# subshell: ALWAYS
#
# Returns the module libraries used by besstandalone when invoked by automake
# tasks like "make check" and "make distcheck". These are not the nominally
# installed libraries but rather the libs compiled by make check in the BES
# builddir.
#
function mk_automake_conf() {
    local config_doc=$(
    cat <<EOF
# -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
# These are the buildir libraries used for running make check/distcheck
BES.module.dap=@abs_top_builddir@/dap/.libs/libdap_module.so
BES.module.cmd=@abs_top_builddir@/xmlcommand/.libs/libdap_xml_module.so
BES.module.h5=@abs_top_builddir@/modules/hdf5_handler/.libs/libhdf5_module.so
BES.module.dmrpp=@abs_top_builddir@/modules/dmrpp_module/.libs/libdmrpp_module.so
BES.module.nc=@abs_top_builddir@/modules/netcdf_handler/.libs/libnc_module.so
BES.module.fonc=@abs_top_builddir@/modules/fileout_netcdf/.libs/libfonc_module.so
# -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
EOF
)
    if test -n "${VERY_VERBOSE}"; then echo "${config_doc}" >&2 ; fi
    echo "${config_doc}"
}


###############################################################################
#
# mk_default_bes_conf()
# subshell: NEVER
#
# Default BES Configuration.
#
function mk_default_bes_conf() {
    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
        echo "# mk_default_bes_conf()" >&2
        echo "# " >&2
    fi

    local default_bes_conf_doc=$(
    cat <<EOF
# produce DMR documents for use with build_dmrpp. The DAP, XML Command
# and HDF5 handler modules are the 'installed' ones (not the modules
# found in the build tree). jhrg 5/11/18

BES.LogName=./bes.log

BES.modules=dap,cmd,h5,dmrpp,nc,fonc

BES.module.dap=@bes_modules_dir@/libdap_module.so
BES.module.cmd=@bes_modules_dir@/libdap_xml_module.so
BES.module.h5=@bes_modules_dir@/libhdf5_module.so
BES.module.dmrpp=@bes_modules_dir@/libdmrpp_module.so
BES.module.nc=@bes_modules_dir@/libnc_module
BES.module.fonc=@bes_modules_dir@/libfonc_module.so

# The value "@hdf5_root_directory@" is replaced at run time.
# BES.Catalog.catalog.RootDirectory=@hdf5_root_directory@
BES.Catalog.catalog.RootDirectory=${BES_DATA_ROOT}
BES.Data.RootDirectory=/dev/null

# The order is crucial here. The dmr++ files must be associated
# with the dmrpp_module while everything else is being
# gobbled up by the greedy regex for the hdf5_handler.
# If the dmrpp.TypeMatch doesn't come first then the
# hdf5_handler will claim the dmr++ files too.
BES.Catalog.catalog.TypeMatch=dmrpp:.*\.(dmrpp)$;
BES.Catalog.catalog.TypeMatch+=h5:.*(\.bz2|\.gz|\.Z)?$;

BES.Catalog.catalog.FollowSymLinks=Yes

BES.UncompressCache.dir=/tmp/hyrax_ux
BES.UncompressCache.prefix=ux_
BES.UncompressCache.size=500

AllowedHosts+=^https?:\/\/

#-----------------------------------------------------------------------#
# FONc handler specific parameters:
#-----------------------------------------------------------------------#
#Make sure this follows the netCDF-4 enhanced model
FONc.ClassicModel=false
#Don't generate global attributes since we only
#care about the variable value information.
FONc.NoGlobalAttrs=true

#-----------------------------------------------------------------------#
# HDF5 handler specific parameters:
#-----------------------------------------------------------------------#
# EnableCF: Groom the HDF5 data to follow the CF conventions
#   (true,yes|false,no, defaults to false)
#
# HDF5 handler keys that are not the compiled-in defaults. jhrg 5/24/22
H5.EnableCheckNameClashing=true
H5.EnableCF=false

EOF
)

    if test -n "${USE_AUTOMAKE_LIBS}"; then
        local automake_libs=$(mk_automake_conf)
        if test -n "${VERBOSE}"; then
            echo "# Using automake_libs" >&2
            if test -n "${VERY_VERBOSE}"; then
                echo "${automake_libs}" >&2
            fi
        fi
        default_bes_conf_doc=$(echo "${default_bes_conf_doc}"; echo "${automake_libs}");
    fi
    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
    fi
    echo "${default_bes_conf_doc}"

}
###############################################################################


dap4ConstraintContainerElement=$(
cat <<EOF
<bes:container name="c">
<bes:dap4constraint>${dap2_ce}</bes:dap4constraint>
</bes:container>
EOF
)
dap2ConstraintContainerElement=$(
cat <<EOF
<bes:container name="c">
<bes:constraint>${dap2_ce}</bes:constraint>
</bes:container>
EOF
)
########################################################################################################################
# mkBesCmd()
# subshell: ALWAYS
#
# Creates a BES request document for the $dap_thing (dmr, ddx, etc)
# from the $source_data_path file and sticks the command in a temp file.

function mkDAP2BesCmd() {
    local source_data_path="${1}"
    local dap_type=${2}
    local dap2_ce="${3}"
    local returnAs="${4}"

    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
        echo "# mkDAP2BesCmd()" >&2
        echo "# source_data_path: ${source_data_path}" >&2
        echo "#         dap_type: ${dap_type} " >&2
        echo "#          dap2_ce: '${dap2_ce}'" >&2
        echo "#         returnAs: '${returnAs}'" >&2
    fi

    local noConstraintContainerElement="<bes:container name=\"c\" />"

    if test -n "${dap2_ce}"; then
        #echo "Applying DAP2 CE: '${dap2_ce}'" >&2
        container_element=$(
        cat <<EOF
<bes:container name="c">
<bes:constraint>${dap2_ce}</bes:constraint>
</bes:container>
EOF
)
    else
        container_element="${noConstraintContainerElement}"
    fi

    local besGET_ELEMENT=""
    if test -n "${returnAs}"; then
        besGET_ELEMENT=$(
        cat <<EOF
</bes:define>
<bes:get type="${dap_type}" definition="d" returnAs="${returnAs}" />
</bes:request>
EOF
)
    else
        besGET_ELEMENT=$(
        cat <<EOF
</bes:define>
<bes:get type="${dap_type}" definition="d" />
</bes:request>
EOF
)
    fi

    local bes_command=$(
    cat <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<bes:request xmlns:bes="http://xml.opendap.org/ns/bes/1.0#" reqID="get_dmrpp.sh">
<bes:setContext name="dap_explicit_containers">no</bes:setContext>
<bes:setContext name="errors">xml</bes:setContext>
<bes:setContext name="max_response_size">0</bes:setContext>

<bes:setContainer name="c">${source_data_path}</bes:setContainer>

<bes:define name="d" space="default">
${container_element}
${besGET_ELEMENT}

EOF
)
    local bes_cmd_file="";
    bes_cmd_file=$(mktemp -t bes_cmd_XXXXXX)
    echo "${bes_command}" > ${bes_cmd_file}

    if test -n "${VERBOSE}"; then
        echo "#     bes_cmd_file: ${bes_cmd_file} " >&2
    fi

    if test -n "${VERY_VERBOSE}"; then
        echo "#    BES Command: " >&2
        cat  "${bes_cmd_file}" >&2
    fi
    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
    fi
    echo "${bes_cmd_file}"
}
########################################################################################################################

########################################################################################################################
# make_bes_conf()
#
# Prepare the bes.conf file - use external if provided otherwise use the here doc.
# Returns the bes conf file name on stdout.
#
function make_bes_conf() {
    local user_supplied_conf_file="${1}"
    local site_conf_file="${2}"

    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
        echo "# mkDAP2BesCmd()" >&2
        echo "# " >&2
        echo "# user_supplied_conf_file: ${user_supplied_conf_file}" >&2
        echo "#          site_conf_file: ${site_conf_file}" >&2
        echo "#" >&2
    fi
    local bes_conf_doc=""

    if test -n "${user_supplied_conf_file}"; then
        bes_conf_doc=$(cat ${user_supplied_conf_file})
    else
        bes_conf_doc=$(mk_default_bes_conf)
    fi

    if test -n "${site_conf_file}"; then
        if test -n "${VERBOSE}"; then
            echo "# Adding additional BES configuration from file: ${2}" >&2
        fi
        bes_conf_doc=$(echo "${bes_conf_doc}"; cat "${site_conf_file}");
    fi
    #    echo "Using BES Configuration: " >&2
    #    echo "${BES_CONF_DOC}" >&2

    if test -n "${VERY_VERBOSE}"; then
        echo "# Using BES Configuration: " >&2
        echo "${bes_conf_doc}" >&2
    fi

    local tmp_conf_file=""
    tmp_conf_file=$(mktemp -t bes_conf_XXXX)
    echo "${bes_conf_doc}" > ${tmp_conf_file}



    if test -n "${VERBOSE}"; then
        echo "# bes_conf_file: ${tmp_conf_file}" >&2
        echo "# "$(ls -l ${tmp_conf_file}) >&2
    fi
        if test -n "${VERY_VERBOSE}"; then
        cat ${tmp_conf_file} >&2
    fi



    echo "${tmp_conf_file}"
}
########################################################################################################################

########################################################################################################################
# getDap()
# Gets the passed $dap response (dmr, ddx, etc) for the file $data_path and places the response in a temp file.
#
function mkDapRequest() {
    local bes_conf_file="${1}"
    local data_path="${2}"
    local dap_type="${3}"
    local dap_ce="${4}"
    local return_as="${5}"
    local output_file="${6}"

    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
        echo "# mkDapRequest()" >&2
        echo "# " >&2
        echo "#  bes_conf_file: ${bes_conf_file}" >&2
        echo "#      data_path: ${data_path}" >&2
        echo "#       dap_type: ${dap_type}" >&2
        echo "#         dap_ce: ${dap_ce}" >&2
        echo "#      return_as: ${return_as}" >&2
        echo "#    output_file: ${output_file}" >&2
        echo "#" >&2
    fi


    local bes_command_file=""
    if test -n "${dap_ce}"; then
        bes_command_file=$(mkDAP2BesCmd ${data_path} ${dap_type} ${dap_ce} ${return_as})
    else
        bes_command_file=$(mkDAP2BesCmd ${data_path} ${dap_type})
    fi
    if test -n "${VERBOSE}"; then 
        echo "#  bes_command_file: ${bes_command_file}" >&2
    fi
    if test -n "${VERY_VERBOSE}"; then 
        cat "${bes_command_file}" >&2  
    fi

    local target_dap_file=""
    if test -n "${output_file}"; then
        target_dap_file=$(echo "${BES_DATA_ROOT}"/"${output_file}")
    else
        target_dap_file=$(mktemp -t ${dap_type}_${return_as}_XXXXXX)
    fi
    if test -n "${VERBOSE}"; then echo "#   target_dap_file: ${target_dap_file}" >&2; fi

    local BESCMD="besstandalone -c ${bes_conf_file} -i ${bes_command_file} -f ${target_dap_file} "
    if test -n "${VERBOSE}"; then echo "#   BESCMD: ${BESCMD}" >&2; fi
    ${BESCMD}
    status=$?
    if test $status -ne 0 ; then
        echo "" >&2
        echo "" >&2
        echo "!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!" >&2
        echo "ERROR! The besstandalone program failed to build a ${dap_type} file!." >&2
        echo "       The configuration is here: ${bes_conf_file}" >&2
        echo "             The command is here: ${bes_command_file}" >&2
        echo "The besstandalone output is here: ${target_dap_file}" >&2
        echo "       besstandalone exit status: $status" >&2
        return $status
    fi

    if test -n "${VERY_VERBOSE}"; then
        echo "# target_dap_file: " >&2
        cat "${target_dap_file}" >&2
    fi

    # This is the return value of the function!
    echo "${target_dap_file}"

    #----------------------------------------------------------
    # I commented this out because it was screwing things up
    # to delete the configuration after the DMR was created but
    # before build_dmrpp had been run. ndp 11/01/21
    #
    # Clean up temporary files if not in debug mode
    #if test -z "${VERBOSE}"; then
    #echo "DAP_CMD: ${DAP_CMD}"
    #echo "BES_CONF: ${BES_CONF}"
    # rm -f ${DAP_CMD} ${BES_CONF}
    #  ;
    #fi
    #----------------------------------------------------------

}
########################################################################################################################

########################################################################################################################
# mk_dmrpp()
# Uses build_dmrpp application to build the requested dmr++ file.
#
function mk_dmrpp() {
    local bes_conf_file="${1}"
    local datafile="${2}"
    local source_dmr_file="${3}"
    local output_filename="${4}"

    local full_data_path="${BES_DATA_ROOT}/${datafile}"

    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
        echo "# mk_dmrpp()" >&2
        echo "#" >&2
        echo "#   BES_DATA_ROOT: ${BES_DATA_ROOT}" >&2
        echo "#       DMRPP_URL: ${DMRPP_URL}" >&2
        echo "#   bes_conf_file: ${bes_conf_file} " >&2
        echo "#        datafile: ${datafile}" >&2
        echo "# source_dmr_file: ${source_dmr_file}" >&2
        echo "# output_filename: ${output_filename}" >&2
        echo "#  full_data_path: ${full_data_path}" >&2
    fi

    if test -z "${JUST_DMR}"; then
        prms="${VERY_VERBOSE}"
        prms="${prms} -c ${bes_conf_file} "
        prms="${prms} -f ${full_data_path} "
        prms="${prms} -r ${source_dmr_file} "
        prms="${prms} -u ${DMRPP_URL} "
        prms="${prms} -M " # Adds the production metadata (version numbers and configuration) to the dmr++ result.
        if test -n "${VERBOSE}"; then echo "#    build_params: ${prms}" >&2; fi
        if test -n "${output_filename}"; then
            build_dmrpp ${prms} > "${output_filename}"
            status=$?
        else
            build_dmrpp ${prms}
            status=$?
        fi
        if test $status -ne 0; then
            echo "ERROR: build_dmrpp ${prms} FAILED! status: $status"
            return $status
        fi
    else
        echo "The JUST_DMR flag is set, skipping dmr++ construction."
    fi

    #if test ! -n "${VERY_VERBOSE}" && test ! -n "${VERBOSE}"; then
    #echo "  mk_dmrpp:BES_CONF: ${BES_CONF}"
    #echo "mk_dmrpp:SOURCE_DMR: ${SOURCE_DMR}"
    #rm -f ${BES_CONF} ${SOURCE_DMR}
    #fi

    # TODO Use trap to ensure these are really removed
    # rm $DMR_CMD $SOURCE_DMR $TMP_CONF
}

#######################################################################################################################
# chk_dmrpp_for_missing_vars()
# Uses check_dmrpp application to identify missing variables in the requested dmr++ file.
#
function chk_dmrpp_for_missing_vars() {
    local dmrpp_file="${1}"
    local mvars_file="${2}"

    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
        echo "# chk_dmrpp_for_missing_vars()" >&2
        echo "#" >&2
        echo "#     dmrpp_file: ${dmrpp_file}" >&2
        echo "#     mvars_file: ${mvars_file}" >&2
    fi

    ck_prms="${dmrpp_file} ${mvars_file}"
    if test -n "${VERBOSE}"; then echo "#   check_dmrpp parameters: ${ck_prms}"  >&2; fi
    if test -n "${mvars_file}"; then
        check_dmrpp ${ck_prms}
        return $?
    else
        echo "The missing_vars file wasn't specified, skipping missing variable construction." >&2
        return 1
    fi
}
########################################################################################################################

###############################################################################
#
# BES Configuration elements to generate missing variable HDF5 sidecar file.
#

function make_missing_conf() {
    local user_supplied_conf_file="${1}"
    local site_conf_file="${2}"


    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
        echo "# make_missing_conf()" >&2
        echo "#" >&2
        echo "# user_supplied_conf_file: ${user_supplied_conf_file}" >&2
        echo "#          site_conf_file: ${site_conf_file}" >&2
    fi



    local missing_conf_elements=$(
    cat <<EOF
# Make sure this follows the netCDF-4 enhanced model
#
FONc.ClassicModel=false
#
# Don't generate global attributes since we only
# care about the variable value information.
#
FONc.NoGlobalAttrs=true
H5.ForceFlattenNDCoorAttr=true
H5.RmConventionAttrPath=true
#
# We don't map 64-bit integer to DMR
# to make it consistent with data value reading.
#
H5.EnableDMR64bitInt=false
#
# When the HDF5 storage size is zero, Fullnamepath
# attribute should not be generated for DMRPP to work.
#
H5.NoZeroSizeFullnameAttr=true
#
EOF
)

    local bes_conf_doc=""
    if test -n "${user_supplied_conf_file}"; then
        if test -n "${VERBOSE}"; then
            echo "# Using: \"${user_supplied_conf_file}\""  >&2
        fi
        bes_conf_doc=$(cat ${user_supplied_conf_file})
    else
        bes_conf_doc=$(mk_default_bes_conf)
    fi

    bes_conf_doc=$(echo "${bes_conf_doc}"; echo "${missing_conf_elements}");

    if test -n "${site_conf_file}"; then
        if test -n "${VERBOSE}"; then
            echo "# Adding additional BES configuration from file: ${2}" >&2
        fi
        bes_conf_doc=$(echo "${bes_conf_doc}"; cat "${site_conf_file}");
    fi

    local missing_bes_conf_file=$(mktemp -t missing_vars_bes_conf_XXXX)

    echo "${bes_conf_doc}" > ${missing_bes_conf_file}

    if test -n "${VERY_VERBOSE}"; then
        echo "# missing_bes_conf_file: ${missing_bes_conf_file}" >&2
        echo "# "$(ls -l ${missing_bes_conf_file}) >&2
        if test -n "${VERY_VERBOSE}"; then
            cat ${missing_bes_conf_file} >&2
        fi
    fi

    echo "${missing_bes_conf_file}"

}
###############################################################################

#######################################################################################################################
# merge_dmrpp_missing()
# Uses merge_dmrpp application to identify missing variables in the requested dmr++ file.
#
function merge_dmrpp_missing() {
    local missing_vars_dmrpp_file="${1}"
    local master_dmrpp_file="${2}"
    local missing_data_url="${3}"
    local missing_vars_file="${4}"

    if test -n "${VERBOSE}"; then
        echo "########################################################################" >&2
        echo "# mg_dmrpp()" >&2
        echo "#" >&2
        echo "# missing_vars_dmrpp_file: ${missing_vars_dmrpp_file}" >&2
        echo "#       master_dmrpp_file: ${master_dmrpp_file}" >&2
        echo "#        missing_data_url: ${missing_data_url}" >&2
        echo "#       missing_vars_file: ${missing_vars_file}" >&2
    fi

    mg_prms="${mg_prms} ${missing_vars_dmrpp_file} "
    mg_prms="${mg_prms} ${master_dmrpp_file} "
    mg_prms="${mg_prms} ${missing_data_url}"
    mg_prms="${mg_prms} ${missing_vars_file} "
    if test -n "${VERBOSE}"; then echo "#   build_params: ${mg_prms}"  >&2; fi
    if test -n "$missing_vars_file"; then
        merge_dmrpp ${mg_prms}
        return $?
    else
        echo "The missing_vars file doesn't exist, there are no missing variables to merge." >&2
        return 1
    fi
}
########################################################################################################################

#######################################################################################################################
# reduce_dmrpp()
# Uses reduce_dmrpp application to identify missing variables in the requested dmr++ file.
#
function reduce_dmrpp() {
    local missing_vars_data_file="${1}"
    local missing_vars_dmrpp_file="${2}"
    local master_sha256="${3}"
    local temporary_storage_file="${4}"

    local mvdf_full_path="${BES_DATA_ROOT}/${missing_vars_data_file}"

    if test -n "${VERBOSE}"; then
        echo "#####################################################################################" >&2
        echo "# reduce_dmrpp()" >&2
        echo "#" >&2
        echo "#  missing_vars_data_file: ${missing_vars_data_file}" >&2
        echo "# missing_vars_dmrpp_file: ${missing_vars_dmrpp_file}" >&2
        echo "#          mvdf_full_path: ${mvdf_full_path}" >&2
        echo "#           master_sha256: ${master_sha256}" >&2
        echo "#  temporary_storage_file: ${temporary_storage_file}" >&2
        echo "#" >&2
    fi

    rd_prms="${rd_prms} ${missing_vars_dmrpp_file} "
    rd_prms="${rd_prms} ${mvdf_full_path} "
    rd_prms="${rd_prms} ${master_sha256}"
    rd_prms="${rd_prms} ${temporary_storage_file} "
    if test -n "${VERBOSE}"; then echo "   build_params: ${rd_prms}"  >&2; fi
    if test -n "${missing_vars_dmrpp_file}"; then
        reduce_mdf ${rd_prms}
        return $?

    else
        echo "The missing_vars_dmrpp_file was not set exist, there are no missing variables to merge." >&2
        return 1
    fi

}
########################################################################################################################

########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################

########################################################################################################################
# dap2_vars()
# Prints a list of DAP2 DDX variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap2_vars() {
    grep -e "<Byte" \
    -e "<Int" \
    -e "<UInt" \
    -e "<Float" \
    -e "<Float" \
    -e "<String" \
    -e "<URL" \
    -e "<Grid" \
    -e "<Sequence" \
    -e "<Structure" \
    -e "<Array" \
    "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap2_attributes()
# Prints a list of DAP2 DDX Attribute declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap2_attributes() {
    grep -e "<Attribute name=" -e "<Value>" "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap4_attributes()
# Prints a list of DAP4 DMR Attribute declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_attributes() {
    grep -e "<Attribute name=" -e "<Value>" "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_vars() {
    grep \
    -e "<Int8" \
    -e "<UInt8" \
    -e "<Byte" \
    -e "<Char" \
    -e "<Int" \
    -e "<UInt" \
    -e "<Float" \
    -e "<String" \
    -e "<URI" \
    -e "<Enumeration" \
    -e "<Sequence" \
    -e "<Structure" \
    -e "<Array" \
    -e "<Group" \
    -e "<Dimension" \
    "${1}" | sed 's/ *$//g' | sort
}
########################################################################################################################

########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_array_counter() {
    dmr_file=${1}
    type=${2}

    #echo "    dmr_file: ${dmr_file}" >&2;
    #echo "   DAP4 type: ${type}" >&2;

    cat "${dmr_file}" | awk -v type=${type} 'BEGIN{
    inVar = 0;
    typeMatchString = "^ *<"type;
    closeMatchString = "^ *</"type;
    match_count=0;
    }
    {
    if( match($0,typeMatchString)==1){
    inVar=1;
    match_count++;
    }
    if( inVar>0){
    if( match($0,closeMatchString)==1){
    inVar=0;
    }
    }
    }END{print match_count;}' -

}
########################################################################################################################

function dap4_array_dim_counter() {
    dmr_file=${1}
    type=${2}
    match_num="${3}"
    awk_params="-v type=${type} -v match_num=${match_num}"

    cat "${dmr_file}" | awk ${awk_params} 'BEGIN{
    inVar = 0;
    typeMatchString = "^ *<"type;
    # print "typeMatchString: " typeMatchString;
    closeMatchString = "^ *</"type
    # print "closeMatchString: " closeMatchString;
    target_dim_count=0;
    match_count=0;
    target_var_name="not found";
    }
    {
    if( match($0,typeMatchString)==1){
    inVar=1;
    match_count++;
    if(match_count==match_num){
    # <Float32 name="ClrOLR_A">
    target_var_name=$2;
    sub("name=\"","",target_var_name);
    sub("\">","",target_var_name);
    }
    }
    if( inVar>0){
    if(match_count==match_num &&  match($0,"^ *<Dim")==1  ){
    target_dim_count++;
    }
    else if( match($0,closeMatchString)==1){
    inVar=0;
    }
    }
    }END{ print target_var_name, target_dim_count; }' -

}
########################################################################################################################

########################################################################################################################
# dap4_vars()
# Prints a list of DAP4 DMR variable declarations found in the file $1
# The leading and trailing whitespace is trimmed from each line, and the result is sorted.
#
function dap4_array_test() {
    dmr_file=${1}
    target_file=${2}
    type=${3}
    #echo "    dmr_file: ${dmr_file}" >&2;
    #echo " target_file: ${target_file}" >&2; 
    #echo "   DAP4 type: ${type}" >&2;

    var_count=$(dap4_array_counter ${dmr_file} ${type})
    if test -n "${VERBOSE}"; then echo "Found ${var_count} variables of type ${type} in DMR: ${dmr_file}" >&2; fi
    if [ ${var_count} -lt 1 ]; then
        echo "ERROR! No variables of type ${type} found in DMR!" >&2
        return 0
    fi

    pick_var=$(echo "${var_count}*${RANDOM}/32767+1" | bc)
    if test -n "${VERBOSE}"; then echo "Picked variable: ${pick_var}" >&2; fi

    name_and_dim=$(dap4_array_dim_counter ${dmr_file} ${type} ${pick_var})
    if test -n "${VERY_VERBOSE}"; then echo "name_and_dim: ${name_and_dim}" >&2; fi

    var_name=$(echo "${name_and_dim}" | awk '{print $1;}' -)
    if test -n "${VERY_VERBOSE}"; then echo "var_name: ${var_name}" >&2; fi

    var_dims=$(echo "${name_and_dim}" | awk '{print $2;}' -)
    if test -n "${VERY_VERBOSE}"; then echo "var_dims: ${var_dims}" >&2; fi

    query_string="${var_name}"
    for ((i = 1; i <= ${var_dims}; i++)); do
        query_string=${query_string}"[0]"
    done
    if test -n "${VERBOSE}"; then echo "   query_string: ${query_string}" >&2; fi

    bes_cmd_file=$(mkDAP2BesCmd "${INPUT_DATA_FILE}" "dods" "${query_string}")
    #if test -n "${VERBOSE}"; then echo "bes_cmd_file: ${bes_cmd_file}" >&2; fi
    dap2_source_response=$(mktemp -t dap2_array_test_source_response_XXXX)
    besstandalone -c ${BES_CONF} -i ${bes_cmd_file} > ${dap2_source_response}
    if test -n "${VERBOSE}"; then echo "dap2_source_response: ${dap2_source_response}" >&2; fi
    if test -n "${VERBOSE}"; then getdap -D -M ${dap2_source_response} >&2; fi

    if test -n "${VERY_VERBOSE}"; then
        echo "dap2_source_response: " >&2
        cat ${dap2_source_response} >&2
    fi

    bes_cmd_file=$(mkDAP2BesCmd "${target_file}" "dods" "${query_string}")
    #if test -n "${VERBOSE}"; then echo "bes_cmd_file: ${bes_cmd_file}" >&2; fi
    dap2_dmrpp_response=$(mktemp -t dap2_array_test_dmrpp_response_XXXX)
    besstandalone -c ${BES_CONF} -i ${bes_cmd_file} > ${dap2_dmrpp_response}
    if test -n "${VERBOSE}"; then echo "dap2_dmrpp_response: ${dap2_dmrpp_response}" >&2; fi
    if test -n "${VERBOSE}"; then getdap -D -M ${dap2_dmrpp_response} >&2; fi

    if test -n "${VERBOSE}"; then echo "Comparing binary responses..." >&2; fi
    cmp ${dap2_source_response} ${dap2_dmrpp_response} >&2
    if [ $? -eq 0 ]; then
        if test -n "${VERBOSE}"; then echo "Responses are the same. w00t" >&2; fi
        return 0
    else
        if test -n "${VERBOSE}"; then echo "ERROR! Responses differ." >&2; fi
        return 100
    fi

}

########################################################################################################################

########################################################################################################################
# compare_files()
# Compares two files by first applying the check_function to each file and then comparing the results of the
# check_function using diff.
#
function compare_files() {
    check_function=${1}
    first_file=${2}
    second_file=${3}
    success="${4}"
    failure="${5}"
    if test -n "${VERY_VERBOSE}"; then
        echo "compare_files() check_function: ${check_function}" >&2
        echo "compare_files()     first_file: ${first_file}" >&2
        echo "compare_files()    second_file: ${second_file}" >&2
    fi

    first_result=$(mktemp -t ${check_function}_result_1_XXXX)
    if test -n "${VERY_VERBOSE}"; then
        echo "compare_files()   first_result: ${first_result}" >&2
    fi
    f_stuff=$(${check_function} ${first_file})
    echo "${f_stuff}" > ${first_result}

    second_result=$(mktemp -t ${check_function}_result_2_XXXX)
    if test -n "${VERY_VERBOSE}"; then
        echo "compare_files()  second_result: ${second_result}" >&2
    fi
    s_stuff=$(${check_function} ${second_file})
    echo "${s_stuff}" > ${second_result}

    retval=0
    diff --ignore-space-change --brief ${first_result} ${second_result}
    if [ $? -eq 0 ]; then
        if test -n "${VERBOSE}"; then
            echo "${success}" >&2
        fi
    else
        echo "${failure}" >&2
        retval=1
    fi
    return ${retval}
}
########################################################################################################################

########################################################################################################################
# dmrpp_inventory_test()
#
function dmrpp_inventory_test() {
    local o_filename="${1}"
    if [[ ${o_filename} == ${BES_DATA_ROOT}* ]]; then
        target_file=$(echo "${o_filename}" | sed -e "s+${BES_DATA_ROOT}++")
    else
        test_file="${BES_DATA_ROOT}/"$(basename ${o_filename})
        if test ! -f ${testfile}; then
            cp ${o_filename} ${BES_DATA_ROOT}
        fi
        target_file=$(basename ${o_filename})
    fi

    if test -n "${EXISTING_DMRPP}"; then
        target_file="${EXISTING_DMRPP}"
    fi
    
    if test -n "${VERBOSE}"; then
        echo "       BES_CONF: ${BES_CONF}" >&2
        echo "INPUT_DATA_FILE: ${INPUT_DATA_FILE}" >&2
        echo "TARGET_DATAFILE: ${target_file}" >&2
    fi

    SOURCE_DDX=$(mkDapRequest "${INPUT_DATA_FILE}" ddx)
    TARGET_DDX=$(mkDapRequest "${target_file}" ddx)

    # SOURCE_DMR=$(mkDapRequest "${INPUT_DATA_FILE}" dmr) # This is done before the dmr++ file is built.
    TARGET_DMR=$(mkDapRequest "${target_file}" dmr)

    retval=0
    # echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap4_vars ${SOURCE_DMR} ${TARGET_DMR} " DAP4 variables: Matched." "ERROR! DAP4 variables mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap4_attributes ${SOURCE_DMR} ${TARGET_DMR} "DAP4 Attributes: Matched." "ERROR! DAP4 Attributes mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap2_vars ${SOURCE_DDX} ${TARGET_DDX} " DAP2 variables: Matched." "ERROR! DAP2 variables mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    compare_files dap2_attributes ${SOURCE_DDX} ${TARGET_DDX} "DAP2 Attributes: Matched." "ERROR! DAP2 Attributes mismatch!"
    retval=$(echo "${retval} + ${?}" | bc)
    #echo "dmrpp_inventory_test: retval: ${retval}"

    return ${retval}
}

########################################################################################################################
# dmrpp_value_test()
#
function dmrpp_value_test() {
    local o_filename="${1}"
    if test -z "${EXISTING_DMRPP}"; then
        target_file="${o_filename}"
    else
        target_file="${EXISTING_DMRPP}"
    fi
    
    if test -n "${VERY_VERBOSE}"; then
        echo "dvt        BES_CONF: ${BES_CONF}" >&2
        echo "dvt SOURCE_DATAFILE: ${INPUT_DATA_FILE}" >&2
        echo "dvt TARGET_DATAFILE: ${target_file}" >&2
        echo "dvt      SOURCE_DMR: ${SOURCE_DMR}" >&2
    fi
    for datatype in Int8 UInt8 Int16 UInt16 Int32 UInt32 Float32 Float64
    do
        dap4_array_test "${SOURCE_DMR}" "${target_file}" "${datatype}"
    done
    return $?
}


########################################################################################################################
# check_aws_config()
#
# Verify that the AWS CLI has been configured with credentials and default region
# Returns non-zero if the AWS CLI is not configured
#
function check_aws_config() {
    aws configure list | grep "access_key" | grep -v "<not set>" > /dev/null
    ret=$?
    if test $ret != 0 ; then
        echo "ERROR - The AWS_ACCESS_KEY_ID is not set." >&2
        return $ret;
    fi
    aws configure list | grep "secret_key" | grep -v "<not set>" > /dev/null
    ret=$?
    if test $ret != 0 ; then
        echo "ERROR - The AWS_SECRET_ACCESS_KEY is not set." >&2
        return $ret;
    fi
    aws configure list | grep "region" | grep -v "<not set>" > /dev/null
    ret=$?
    if test $ret != 0 ; then
        echo "WARNING - The AWS_DEFAULT_REGION is not set." >&2
        return 0;
    fi
}


########################################################################################################################
# merge_missing()
#
# This function merges the missing variables (or not, depending on the state of
# the global MERGE_MISSING_VARS env var.)
#
function merge_missing() {

local status=0

if test -n "${MERGE_MISSING_VARS}"; then
    if test -n "${VERBOSE}"; then
        echo "#####################################################################################" >&2
        echo "# merge_missing()" >&2
        echo "#" >&2
    fi


    # use $PATH/check_dmrpp to query dmrpp for missing CF domain variables [requires ${OUTPUT_FILE}; -o option]
    missing_vars_file=$(mktemp -t missing_vars_XXXX)
    chk_dmrpp_for_missing_vars ${OUTPUT_FILE} ${missing_vars_file}
    status=$?
    if test -n "${VERBOSE}" ; then echo "# chk_dmrpp_for_missing_vars status: ${status}"; fi
    if test $status -ne 0; then
        echo "ERROR: chk_dmrpp_for_missing_vars ${OUTPUT_FILE} ${missing_vars_file} FAILED! status: ${status}" >&2;
        return $status
    fi


    # check-dmrpp will write to the missing_vars_file if there are any missing variables.
    if test -s ${missing_vars_file}; then
        if test -n "${VERBOSE}"; then echo "# The missing variables file: ${missing_vars_file} contains bytes." >&2; fi
        local missing_variables=""
        missing_variables=$(cat ${missing_vars_file})
        if test -n "${VERBOSE}"; then echo "# Identified the missing variables: ${missing_variables}" >&2; fi

        # augment BES_CONF_FILE with additional H5 parameters necessary to synthesize missing_variables from INPUT_DATA_FILE.
        local mk_missing_conf_file=""
        mk_missing_conf_file=$(make_missing_conf "${BES_CONF_FILE}" "${SITE_CONF_FILE}")

        # insert '_missing' into INPUT_DATA_FILE name and use for sidecar_missing_file name
        local sidecar_missing_file="${INPUT_DATA_FILE}.missing"
        if test -n "${VERBOSE}"; then echo "#  Missing variables data file: ${sidecar_missing_file}" >&2; fi

        # use besstandalone to generate sidecar_missing_file
        full_output_file=""
        full_output_file=$(mkDapRequest ${mk_missing_conf_file} ${INPUT_DATA_FILE} dods ${missing_variables} netcdf-4 ${sidecar_missing_file})
        status=$?
        if test -n "${VERBOSE}" ; then echo "# mkDapRequest status: ${status}"; fi
        if test ${status} -ne 0; then
            echo "ERROR: mkDapRequest ${INPUT_DATA_FILE} dods ${missing_variables} netcdf-4 ${sidecar_missing_file} FAILED! status: $status" >&2
            return $status
        fi
        if test -n "${VERBOSE}" ; then echo "# "$(ls -l ${sidecar_missing_file}); fi



        local bes_conf_file=""
        bes_conf_file=$(make_bes_conf "${BES_CONF_FILE}" "${SITE_CONF_FILE}")  # reset BES_CONF_FILE; removing additional H5 parameters

        local missing_vars_dmr_file=""
        missing_vars_dmr_file=$(mkDapRequest ${bes_conf_file} ${sidecar_missing_file} dmr) # use besstandalone to generate dmr for sidecar_missing_file
        status=$?
        if test -n "${VERBOSE}" ; then echo "# mkDapRequest status: ${status}"; fi
        if test ${status} -ne 0; then
            echo "ERROR: mkDapRequest() ${bes_conf_file} ${sidecar_missing_file} dmr  FAILED! status: $status" >&2
            return $status
        fi

        master_dmrpp_file="${OUTPUT_FILE}"  # save original dmrpp filename

        local missing_dmrpp_file=""
        if test -n "${REDUCE_MISSING_FILES}"; then
            if test ! -s ${MASTER_SHA256}; then
                missing_dmrpp_file="${BES_DATA_ROOT}/${sidecar_missing_file}.dmrpp"
            else
                missing_dmrpp_file=$(mktemp -t missing_vars_dmrpp_XXXXXX) # generate temporary dmrpp filename for sidecar_missing_file
            fi
        else
            missing_dmrpp_file=$(mktemp -t missing_vars_dmrpp_XXXXXX) # generate temporary dmrpp filename for sidecar_missing_file
        fi

        mk_dmrpp "${bes_conf_file}" "${sidecar_missing_file}" "${missing_vars_dmr_file}" "${missing_dmrpp_file}" # use $PATH/build_dmrpp to generate dmrpp for sidecar_missing_file
        status=$?
        if test -n "${VERBOSE}" ; then echo "# mk_dmrpp status: ${status}"; fi
        if test $status -ne 0; then
            echo "ERROR: mk_dmrpp  ${bes_conf_file} ${sidecar_missing_file} ${missing_vars_dmr_file} ${missing_dmrpp_file} FAILED! status: $status" >&2
            return $status
        fi

        if test -n "${REDUCE_MISSING_FILES}"; then
            local tempstore_file=""
            tempstore_file=$(mktemp -t tmpstore_XXXX) # generate temporary filename for tempstore to hold missing_dmrpp info
            if test -n "${VERBOSE}"; then
                echo "#        MASTER_SHA256: ${MASTER_SHA256}" >&2;
                echo "#   missing_dmrpp_file: ${missing_dmrpp_file}" >&2;
                echo "# sidecar_missing_file: ${sidecar_missing_file}" >&2;
                echo "#       tempstore_file: ${tempstore_file}" >&2;
            fi

            # use $PATH/reduce_mdf to merge sidecar_missing_file dmrpp with master_dmrpp_file
            reduce_dmrpp "${sidecar_missing_file}" "${missing_dmrpp_file}" "${MASTER_SHA256}" "${tempstore_file}"
            status=$?
            echo "# reduce_dmrpp status: ${status}";
            if test $status -ne 0; then
                echo "ERROR: reduce_dmrpp ${sidecar_missing_file} ${missing_dmrpp_file} ${MASTER_SHA256} ${tempstore_file}  FAILED! status: $status" >&2
                return $status
            fi
            #echo "reduce_dmrpp: ${retval}"

            if test -s ${tempstore_file}; then # if tempstore_file is not empty then there will be temp that need to be removed.
                temp_sidecar_dmrpp=${missing_dmrpp_file}
                temp_sidecar_file="${BES_DATA_ROOT}/${sidecar_missing_file}"
                missing_dmrpp_file=$(awk -F'[ ]' '{print $2}' "${tempstore_file}")
            fi

        fi

        if test -n "${VERBOSE}"; then
            echo "#   missing_dmrpp_file: ${missing_dmrpp_file}" >&2;
            echo "#    master_dmrpp_file: ${master_dmrpp_file}" >&2;
            echo "# sidecar_missing_file: ${sidecar_missing_file}" >&2;
            echo "#    missing_vars_file: ${missing_vars_file}" >&2;
        fi

        # set 'href' content to use when merging chunks from sidecar_missing_file dmrpp into master_dmrpp_file
        local missing_data_url_path="OPeNDAP_DMRpp_MISSING_DATA_ACCESS_URL"
        if test -n "${MISSING_DATA_HREF}"; then
            missing_data_url_path="${MISSING_DATA_HREF}"
        fi
        # use $PATH/merge_dmrpp to merge sidecar_missing_file dmrpp with master_dmrpp_file
        merge_dmrpp_missing  "${missing_dmrpp_file}" "${master_dmrpp_file}" "${missing_data_url_path}" "${missing_vars_file}"
        status=$?
        if test -n "${VERBOSE}" ; then echo "# merge_dmrpp_missing status: ${status}"; fi
        if test $status -ne 0; then
            echo "ERROR: merge_dmrpp_missing ${missing_dmrpp_file} ${master_dmrpp_file} ${missing_data_url_path} ${missing_vars_file} FAILED! status: $status" >&2
            return $status
        fi

    else
        echo " There are no missing variables to merge."
    fi
fi
    return 0
}

########################################################################################################################
# run_tests()
#
# This function conditionally runs the dmr++ sanity checking tests
#
function run_tests(){
    local o_filename="${1}"

    if test -n "${RUN_INVENTORY_TESTS}"; then
        dmrpp_inventory_test "${o_filename}"
        retval=$(echo "${retval} + ${?}" | bc)
        #echo "dmrpp_inventory_test: retval: ${retval}"
    fi

    if test -n "${RUN_VALUE_TESTS}"; then
        dmrpp_value_test "${o_filename}"
        retval=$(echo "${retval} + ${?}" | bc)
        #echo "retval: ${retval}";
    fi
}

########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
#
# main() (such as it is in bashlandia)
#
#
#

function main(){
    trap cleanup_temp_files EXIT
    # Here we test to see if the input file name is actually an S3 URL
    # and if it is we adjust the INPUT_DATA_FILE and go out and get the
    # object from S3.
    s3_granule=
    if [[ "${INPUT_DATA_FILE}" =~ ^s3:\/\/.* ]]; then
        s3_granule="${INPUT_DATA_FILE}"
       echo "Detected S3 URL as data input: ${s3_granule}" >&2

        set +e
        check_aws_config
        ret=$?
        if test $ret != 0; then
          echo "ERROR - The AWS CLI is not configured. Exiting." >&2
          exit 1
        fi

        INPUT_DATA_FILE=$(basename "${s3_granule}")
        echo "INPUT_DATA_FILE: ${INPUT_DATA_FILE}" >&2

        local_file=""
        if test "${BES_DATA_ROOT}" = "/"; then # TODO - This should test for ends_with("/")
          local_file="/${INPUT_DATA_FILE}"
        else
          local_file="${BES_DATA_ROOT}/${INPUT_DATA_FILE}"
        fi
        echo "Copying S3 object to: ${local_file}" >&2

        aws s3 cp ${s3_granule} ${local_file}
        result=$?
        if test $result != 0; then
          echo "ERROR - Failed to acquire S3 object. (status: $result) Exiting..." >&2
          exit $result
        fi
        set -e
    fi

    local bes_conf_file=""
    bes_conf_file=$(make_bes_conf "${BES_CONF_FILE}" "${SITE_CONF_FILE}")

    local dmr_file=""
    dmr_file=$(mkDapRequest "${bes_conf_file}" "${INPUT_DATA_FILE}" dmr)

  # If 'JUST_DMR' is set redirect SOURCE_DMR to either <stdout> or $OUTPUT_FILE
    if test -n "${JUST_DMR}"; then
        if test -z "${OUTPUT_FILE}"; then
            cat ${dmr_file} >&2
        else
            cat ${dmr_file} > ${OUTPUT_FILE}
            if test -z "${VERBOSE}"; then
                rm -f ${dmr_file}
            fi
        fi
    exit 0
    fi


  mk_dmrpp "${bes_conf_file}" "${INPUT_DATA_FILE}" "${dmr_file}" "${OUTPUT_FILE}"
  status=$?
  if test $status -ne 0; then
    echo "ERROR: mk_dmrpp() ${bes_conf_file} ${INPUT_DATA_FILE} ${dmr_file} ${OUTPUT_FILE} Failed!. status: $status" >&2
    exit $status
  fi

  # if test -n "${VERBOSE}"; then echo "main() - TEMP_FILE_LIST: ${TEMP_FILE_LIST}" >&2; fi

  # Merge the missing variable data (conditional)
  merge_missing
  status=$?
  if test $status -ne 0; then
    echo "ERROR: merge_missing() FAILED!. status: $status" >&2
    exit $status
  fi


  # Run the dmr++ tests (conditional)
  run_tests "${OUTPUT_FILE}"

  # Push the dmr++ to S3 target (conditional)
  if test -n "${s3_granule}" && test -n "${S3_UPLOAD}"; then
    if test -z "${OUTPUT_FILE}"; then
      echo "#---------------------------------------------------------------------" >&2
      echo "ERROR - Unable to upload dmr++ file because the output file name has not been set!" >&2
      echo "        Use the -o parameter. To set the output file name" >&2
      echo "-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -" >&2
      show_usage >&2
      echo "#---------------------------------------------------------------------" >&2
      exit 1
    fi
    s3_dmrpp="${s3_granule}.dmrpp"
    echo "Uploading dmr++ file (${OUTPUT_FILE}) to: ${s3_dmrpp}" >&2
    set +e
    aws s3 cp "${OUTPUT_FILE}" "${s3_dmrpp}"
    result=$?
    if test $result != 0; then
      echo "ERROR - Failed to upload S3 object. Exiting..." >&2
      exit 1
    fi
    set -e
  fi

  # Cleanup the mess, or not (conditional)
  if test -z "${VERBOSE}"; then
    if test -n "${MERGE_MISSING_VARS}"; then
      echo "#     main:MISSING_VARS_FILE: ${missing_vars_file}"
      echo "#  main:SIDECAR_MISSING_FILE: ${temp_sidecar_file}"
      echo "# main:SIDECAR_MISSING_DMRPP: ${temp_sidecar_dmrpp}"
      echo "#        main:TEMPSTORE_FILE: ${tempstore_file}"
      export TEMP_FILE_LIST="${TEMP_FILE_LIST} ${missing_vars_file} ${temp_sidecar_file} ${temp_sidecar_dmrpp} ${tempstore_file}"
    fi
    #echo " main:SOURCE_DMR: ${SOURCE_DMR}"
  fi

  #echo "retval: ${retval}";
  exit $retval

  # rm -f ${SOURCE_DMR} ${SOURCE_DDX} ${TARGET_DDX} ${TARGET_DMR} ${DDX_CMD} ${DMR_CMD} ${BES_CONF}

  #./get_dmrpp -u "http://test.opendap.org/data/dmrpp/AIRS.2015.01.01.L3.RetStd_IR001.v6.0.11.0.G15013155825.nc.h5" -o airs.h5.dmrpp -T -v  airs.h5
  #./get_dmrpp -u "http://test.opendap.org/data/dmrpp/SMAP_L3_SM_P_20150406_R14010_001.h5" -o smap.h5.dmrpp -T -v  smap.h5
}

main
exit $?
