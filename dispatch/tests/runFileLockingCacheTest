#!/bin/bash
#
# This test script checks to see if advisory file locking
# works on a system.
#
# This is acheived by launching two processes. The first 
# process is launched as a background job. It creates
# and exclusively locks a cache file for a period of time.
# The second process attempts to get a shared read lock on
# the same cache file. Since the first process is still running
# it still holds the exclusive lock. And the code that acquires
# the read lock will block unitl one is available. So the total 
# time for the "get and hold a read lock" activiy will take at 
# least the sum of the time that the first process holds the write 
# lock PLUS the time that the second process holds the read lock.
# If, however, advisory file locking is not working, then the
# second processes execution time should be nominally the same as
# the time it held the read lock, as it didn't wait for the first
# process to release the exclusive write lock.
#
#
#
#
# Exclusive Write Lock Configurqtion
write_lock_hold_time=7;
write_lock_elapsed=0;
#
# Shared Read Lock Configurqtion
read_lock_hold_time=3;
read_lock_elapsed=0;
#
# Time it should take if
minimum_expected_time=`echo "$write_lock_hold_time+$read_lock_hold_time" | bc`


function write_lock {
    write_lock_hold_time=$1;
    write_lock_background=$2;
    # echo "write_lock() hold: $write_lock_hold_time seconds";
    amper="&";
    write_lock_start_time=`date "+%s"`;
    if [ ${write_lock_background} == "true" ]
    then
        ./FileLockingCacheTest -x $write_lock_hold_time &
    else 
        ./FileLockingCacheTest -x $write_lock_hold_time;    
    fi
    ret=$?;
    echo "FileLockingCacheTest status: $ret"
    write_lock_end_time=`date "+%s"`;
    write_lock_elapsed=`echo "$write_lock_end_time - $write_lock_start_time" | bc`
    return $ret;
}

function purge_cache {
    ./FileLockingCacheTest -p;
}

function read_lock {
    read_lock_hold_time=$1;
    read_lock_background=$2;
    # echo "read_lock() hold: $read_lock_hold_time seconds";
    read_lock_start_time=`date "+%s"`;
    if [ ${read_lock_background} == "true" ]
    then
        ./FileLockingCacheTest -r $read_lock_hold_time &
    else 
        ./FileLockingCacheTest -r $read_lock_hold_time;    
    fi
    ret=$?;
    read_lock_end_time=`date "+%s"`;
    read_lock_elapsed=`echo "$read_lock_end_time - $read_lock_start_time" | bc`
    return $ret;
}

##########################################################
##########################################################
#
#
# Clear the decks for the test.
errno=0;
purge_cache;

#
# In a background job, create and lock for writing
# the cache test file. Hold this lock for 
# write_lock_hold_time seconds.
write_lock $write_lock_hold_time "true";
v=$?
echo "write_lock returned: $v"
echo "write_lock_elapsed: $write_lock_elapsed"

#
# While the proevious lock is being held, make
# a blocking call to get a read lock. This,
# if Advisory File Locking is working should 
# block until the write_lock job releases the lock.
read_lock $read_lock_hold_time "false";
v=$?
echo "read_lock returned: $v"
echo "read_lock_elapsed:  $read_lock_elapsed"


#
# If Advisory File Locking is working then we know that the
# read_lock_elapsed time should be write_lock_hold_time + read_lock_hold_time
# and if it's not working then we would expect the read_lock_elapsed time to be
# closer to the read_lock_hold_time.
if [ ${read_lock_elapsed} -lt ${minimum_expected_time} ] 
then
    (>&2 echo "ERROR! It appears that Advisory File Locking is not working on this system.")
    errno=1;
else 
    (>&2 echo "Advisory File Locking appears to be working on this system.")
fi

# Another call to write_lock should fail because the cache file exists.
write_lock $write_lock_hold_time "false";
status=$?
if [ ${status} -ne 0 ] 
then
    echo "Expected Fail: Unable to get another exclusive write lock on the exisiting cache file. status: $status"
else
    echo "ERROR! Successfully create and acquired an exclusive 
          write lock on the exisiting cache file. This should not be possible. status $status"
    errno=$status;
fi

# Multiple concurrent calls to read lock should work.
# First call runs in background holds lot for 10 seconds.
read_lock 10 "true";
r1_status=$?
echo "read_lock returned: $r2_status read_lock_elapsed: $read_lock_elapsed"
# Second call runs in foreground an holds lock for one second 
read_lock 1 "false";
r2_status=$?
echo "read_lock returned: $r2_status read_lock_elapsed: $read_lock_elapsed"
max_time=5;

if [ ${read_lock_elapsed} -gt ${max_time} ]
then
    echo "ERROR! Unable to share read locks. read_lock_elapsed 
          should be less than $max_time seconds. read_lock_elapsed: $read_lock_elapsed";
    errno=1;
else 
    echo "Shared read lock acquired and released. read_lock_elapsed: $read_lock_elapsed"
fi

exit $errno;








